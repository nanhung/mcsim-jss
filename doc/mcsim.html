<HTML>
<HEAD>
<!-- This HTML file has been created by texi2html 1.51
     from mcsim.texinfo on 15 November 1997 -->

<TITLE>MCSim User' Manual</TITLE>
</HEAD>
<BODY>
<H1>MCSim User' Manual</H1>
<P>
<P><HR><P>
<H1>Table of Contents</H1>
<UL>
<LI><A NAME="TOC1" HREF="mcsim.html#SEC1">Software License</A>
<UL>
<LI><A NAME="TOC2" HREF="mcsim.html#SEC2">PREAMBLE</A>
<LI><A NAME="TOC3" HREF="mcsim.html#SEC3">TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION</A>
</UL>
<LI><A NAME="TOC4" HREF="mcsim.html#SEC4">Overview</A>
<UL>
<LI><A NAME="TOC5" HREF="mcsim.html#SEC5">General procedure</A>
<LI><A NAME="TOC6" HREF="mcsim.html#SEC6">Types of simulations</A>
<LI><A NAME="TOC7" HREF="mcsim.html#SEC7">Major changes introduced with version 4.2.0</A>
</UL>
<LI><A NAME="TOC8" HREF="mcsim.html#SEC8">Installation</A>
<UL>
<LI><A NAME="TOC9" HREF="mcsim.html#SEC9">System requirements</A>
<LI><A NAME="TOC10" HREF="mcsim.html#SEC10">Distribution</A>
<LI><A NAME="TOC11" HREF="mcsim.html#SEC11">Machine-Specific Installation</A>
</UL>
<LI><A NAME="TOC12" HREF="mcsim.html#SEC12">Working Through an Example</A>
<LI><A NAME="TOC13" HREF="mcsim.html#SEC13">Defining Models</A>
<UL>
<LI><A NAME="TOC14" HREF="mcsim.html#SEC14">Using Mod to process model description files</A>
<LI><A NAME="TOC15" HREF="mcsim.html#SEC15">Syntax of the model description file</A>
<UL>
<LI><A NAME="TOC16" HREF="mcsim.html#SEC16">General syntax</A>
<LI><A NAME="TOC17" HREF="mcsim.html#SEC17">Global parameter declarations</A>
<LI><A NAME="TOC18" HREF="mcsim.html#SEC18">Special functions</A>
<LI><A NAME="TOC19" HREF="mcsim.html#SEC19">Input functions</A>
<LI><A NAME="TOC20" HREF="mcsim.html#SEC20">Dynamics specifications</A>
<LI><A NAME="TOC21" HREF="mcsim.html#SEC21">Parameter scaling</A>
<LI><A NAME="TOC22" HREF="mcsim.html#SEC22">Output calculations</A>
<LI><A NAME="TOC23" HREF="mcsim.html#SEC23">Comments on style</A>
<LI><A NAME="TOC24" HREF="mcsim.html#SEC24">Note about models</A>
</UL>
</UL>
<LI><A NAME="TOC25" HREF="mcsim.html#SEC25">Specifying Simulations</A>
<UL>
<LI><A NAME="TOC26" HREF="mcsim.html#SEC26">Using the compiled program</A>
<LI><A NAME="TOC27" HREF="mcsim.html#SEC27">Syntax of the simulation definition file</A>
<LI><A NAME="TOC28" HREF="mcsim.html#SEC28">Global specifications</A>
<UL>
<LI><A NAME="TOC29" HREF="mcsim.html#SEC29"><CODE>SimType()</CODE> specification</A>
<LI><A NAME="TOC30" HREF="mcsim.html#SEC30"><CODE>Integrate()</CODE> specification</A>
<LI><A NAME="TOC31" HREF="mcsim.html#SEC31"><CODE>OutputFile()</CODE> specification</A>
<LI><A NAME="TOC32" HREF="mcsim.html#SEC32"><CODE>MonteCarlo()</CODE> specification</A>
<LI><A NAME="TOC33" HREF="mcsim.html#SEC33"><CODE>Distrib()</CODE> specification</A>
<LI><A NAME="TOC34" HREF="mcsim.html#SEC34"><CODE>MCMC()</CODE> specification</A>
<LI><A NAME="TOC35" HREF="mcsim.html#SEC35"><CODE>SetPoints()</CODE> specification</A>
</UL>
<LI><A NAME="TOC36" HREF="mcsim.html#SEC36">Specifying basic conditions to simulate</A>
<UL>
<LI><A NAME="TOC37" HREF="mcsim.html#SEC37"><CODE>Experiment</CODE> definition</A>
<LI><A NAME="TOC38" HREF="mcsim.html#SEC38"><CODE>StartTime()</CODE> specification</A>
<LI><A NAME="TOC39" HREF="mcsim.html#SEC39"><CODE>Print()</CODE> specification</A>
<LI><A NAME="TOC40" HREF="mcsim.html#SEC40"><CODE>PrintStep()</CODE> specification</A>
<LI><A NAME="TOC41" HREF="mcsim.html#SEC41"><CODE>Data()</CODE> specification</A>
</UL>
<LI><A NAME="TOC42" HREF="mcsim.html#SEC42">Specifying a statistical model</A>
<UL>
<LI><A NAME="TOC43" HREF="mcsim.html#SEC43"><CODE>Level</CODE> definition</A>
</UL>
<LI><A NAME="TOC44" HREF="mcsim.html#SEC44">Analyzing results</A>
<LI><A NAME="TOC45" HREF="mcsim.html#SEC45">Error Handling</A>
</UL>
<LI><A NAME="TOC46" HREF="mcsim.html#SEC46">Bibliographic References</A>
<LI><A NAME="TOC47" HREF="mcsim.html#SEC47">Common Pitfalls</A>
<LI><A NAME="TOC48" HREF="mcsim.html#SEC48">Using <CODE>make</CODE></A>
<LI><A NAME="TOC49" HREF="mcsim.html#SEC49">Examples</A>
<UL>
<LI><A NAME="TOC50" HREF="mcsim.html#SEC50"><TT>`linear.model'</TT></A>
<LI><A NAME="TOC51" HREF="mcsim.html#SEC51"><TT>`1cpt.model'</TT>: A sample model description file</A>
<LI><A NAME="TOC52" HREF="mcsim.html#SEC52"><TT>`perc.model'</TT>: A sample model description file</A>
<LI><A NAME="TOC53" HREF="mcsim.html#SEC53"><TT>`perc.lsodes.in'</TT></A>
</UL>
<LI><A NAME="TOC54" HREF="mcsim.html#SEC54">Concept Index</A>
</UL>
<P><HR><P>


<H1><A NAME="SEC1" HREF="mcsim.html#TOC1">Software License</A></H1>
<P>
<A NAME="IDX1"></A>
<A NAME="IDX2"></A>

</P>

<P>
<B>GNU GENERAL PUBLIC LICENSE</B>

</P>
<P>
Version 2, June 1991

</P>
<P>
Copyright (C) 1989, 1991 Free Software Foundation, Inc. 59 Temple Place
- Suite 330, Boston, MA 02111-1307, USA

</P>
<P>
Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.

</P>



<H2><A NAME="SEC2" HREF="mcsim.html#TOC2">PREAMBLE</A></H2>

<P>
The licenses for most software are designed to take away your freedom to
share and change it. By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free software--to
make sure the software is free for all its users. This General Public
License applies to most of the Free Software Foundation's software and
to any other program whose authors commit to using it. (Some other Free
Software Foundation software is covered by the GNU Library General
Public License instead.) You can apply it to your programs, too.

</P>
<P>
When we speak of free software, we are referring to freedom, not price.
Our General Public Licenses are designed to make sure that you have the
freedom to distribute copies of free software (and charge for this
service if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs; and that you know you can do these things.

</P>
<P>
To protect your rights, we need to make restrictions that forbid anyone
to deny you these rights or to ask you to surrender the rights. These
restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

</P>
<P>
For example, if you distribute copies of such a program, whether gratis
or for a fee, you must give the recipients all the rights that you have.
You must make sure that they, too, receive or can get the source code.
And you must show them these terms so they know their rights.

</P>
<P>
We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

</P>
<P>
Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software. If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

</P>
<P>
Finally, any free program is threatened constantly by software patents.
We wish to avoid the danger that redistributors of a free program will
individually obtain patent licenses, in effect making the program
proprietary. To prevent this, we have made it clear that any patent must
be licensed for everyone's free use or not licensed at all.

</P>
<P>
The precise terms and conditions for copying, distribution and
modification follow.

</P>



<H2><A NAME="SEC3" HREF="mcsim.html#TOC3">TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION</A></H2>

<P>
0. This License applies to any program or other work which contains a
notice placed by the copyright holder saying it may be distributed under
the terms of this General Public License. The "Program", below, refers
to any such program or work, and a "work based on the Program" means
either the Program or any derivative work under copyright law: that is
to say, a work containing the Program or a portion of it, either
verbatim or with modifications and/or translated into another language.
(Hereinafter, translation is included without limitation in the term
"modification".) Each licensee is addressed as "you".

</P>
<P>
Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope. The act of running
the Program is not restricted, and the output from the Program is
covered only if its contents constitute a work based on the Program
(independent of having been made by running the Program). Whether that
is true depends on what the Program does.

</P>
<P>
1. You may copy and distribute verbatim copies of the Program's source
code as you receive it, in any medium, provided that you conspicuously
and appropriately publish on each copy an appropriate copyright notice
and disclaimer of warranty; keep intact all the notices that refer to
this License and to the absence of any warranty; and give any other
recipients of the Program a copy of this License along with the Program.

</P>
<P>
You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

</P>
<P>
2. You may modify your copy or copies of the Program or any portion of
it, thus forming a work based on the Program, and copy and distribute
such modifications or work under the terms of Section 1 above, provided
that you also meet all of these conditions:

</P>
<P>
* a) You must cause the modified files to carry prominent
notices stating that you changed the files and the date of any
change.
</P>
<P>
* b) You must cause any work that you distribute or publish,
that in whole or in part contains or is derived from the Program or any
part thereof, to be licensed as a whole at no charge to all third
parties under the terms of this License.
</P>
<P>
* c) If the modified program normally reads commands
interactively when run, you must cause it, when started running for such
interactive use in the most ordinary way, to print or display an
announcement including an appropriate copyright notice and a notice that
there is no warranty (or else, saying that you provide a warranty) and
that users may redistribute the program under these conditions, and
telling the user how to view a copy of this License. (Exception: if the
Program itself is interactive but does not normally print such an
announcement, your work based on the Program is not required to print an
announcement.)
</P>
<P>
These requirements apply to the modified work as a whole. If
identifiable sections of that work are not derived from the Program, and
can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works. But when you
distribute the same sections as part of a whole which is a work based on
the Program, the distribution of the whole must be on the terms of this
License, whose permissions for other licensees extend to the entire
whole, and thus to each and every part regardless of who wrote it.

</P>
<P>
Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

</P>
<P>
In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of a
storage or distribution medium does not bring the other work under the
scope of this License.

</P>
<P>
3. You may copy and distribute the Program (or a work based on it, under
Section 2) in object code or executable form under the terms of Sections
1 and 2 above provided that you also do one of the following:

</P>
<P>
* a) Accompany it with the complete corresponding
machine-readable source code, which must be distributed under the terms
of Sections 1 and 2 above on a medium customarily used for software
interchange; or,
</P>
<P>
* b) Accompany it with a written offer, valid for at least three
years, to give any third party, for a charge no more than your cost of
physically performing source distribution, a complete machine-readable
copy of the corresponding source code, to be distributed under the terms
of Sections 1 and 2 above on a medium customarily used for software
interchange; or,
</P>
<P>
* c) Accompany it with the information you received as to the
offer to distribute corresponding source code. (This alternative is
allowed only for noncommercial distribution and only if you received the
program in object code or executable form with such an offer, in accord
with Subsection b above.)
</P>
<P>
The source code for a work means the preferred form of the work for
making modifications to it. For an executable work, complete source code
means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to control
compilation and installation of the executable. However, as a special
exception, the source code distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies the
executable.

</P>
<P>
If distribution of executable or object code is made by offering access
to copy from a designated place, then offering equivalent access to copy
the source code from the same place counts as distribution of the source
code, even though third parties are not compelled to copy the source
along with the object code.

</P>
<P>
4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License. Any attempt otherwise
to copy, modify, sublicense or distribute the Program is void, and will
automatically terminate your rights under this License. However, parties
who have received copies, or rights, from you under this License will
not have their licenses terminated so long as such parties remain in
full compliance.

</P>
<P>
5. You are not required to accept this License, since you have not
signed it. However, nothing else grants you permission to modify or
distribute the Program or its derivative works. These actions are
prohibited by law if you do not accept this License. Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and all
its terms and conditions for copying, distributing or modifying the
Program or works based on it.

</P>
<P>
6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions. You may not impose any further restrictions
on the recipients' exercise of the rights granted herein. You are not
responsible for enforcing compliance by third parties to this License.

</P>
<P>
7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License. If you cannot distribute
so as to satisfy simultaneously your obligations under this License and
any other pertinent obligations, then as a consequence you may not
distribute the Program at all. For example, if a patent license would
not permit royalty-free redistribution of the Program by all those who
receive copies directly or indirectly through you, then the only way you
could satisfy both it and this License would be to refrain entirely from
distribution of the Program.

</P>
<P>
If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

</P>
<P>
It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is implemented
by public license practices. Many people have made generous
contributions to the wide range of software distributed through that
system in reliance on consistent application of that system; it is up to
the author/donor to decide if he or she is willing to distribute
software through any other system and a licensee cannot impose that
choice.

</P>
<P>
This section is intended to make thoroughly clear what is believed to be
a consequence of the rest of this License.

</P>
<P>
8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License may
add an explicit geographical distribution limitation excluding those
countries, so that distribution is permitted only in or among countries
not thus excluded. In such case, this License incorporates the
limitation as if written in the body of this License.

</P>
<P>
9. The Free Software Foundation may publish revised and/or new versions
of the General Public License from time to time. Such new versions will
be similar in spirit to the present version, but may differ in detail to
address new problems or concerns.

</P>
<P>
Each version is given a distinguishing version number. If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation. If the Program does not specify a version
number of this License, you may choose any version ever published by the
Free Software Foundation.

</P>
<P>
10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the
author to ask for permission. For software which is copyrighted by the
Free Software Foundation, write to the Free Software Foundation; we
sometimes make exceptions for this. Our decision will be guided by the
two goals of preserving the free status of all derivatives of our free
software and of promoting the sharing and reuse of software generally.

</P>

<P>
NO WARRANTY

</P>
<P>
11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW. EXCEPT WHEN
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER
EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE
ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH
YOU. SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL
NECESSARY SERVICING, REPAIR OR CORRECTION.

</P>
<P>
12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR
DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL
DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM
(INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED
INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF
THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR
OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

</P>
<P>
END OF TERMS AND CONDITIONS

</P>



<H1><A NAME="SEC4" HREF="mcsim.html#TOC4">Overview</A></H1>
<P>
<A NAME="IDX3"></A>

</P>

<P>
MCSim consists of two pieces, a model generator and a simulation engine.
The model generator, <STRONG>mod</STRONG>, was created to facilitate the model
maintenance and simulation definition, while keeping execution time
fast. Other programs have been created to the same end, the Matlab
family of graphical interactive programs being some of the more general
and easy to use. Still, many available tools are not optimal for
performing time and computer intensive Monte Carlo analyses. MCSim was
created specifically to this end: to perform Monte Carlo analyses in a
highly optimized, and easy to maintain environment.

</P>



<H2><A NAME="SEC5" HREF="mcsim.html#TOC5">General procedure</A></H2>

<P>
Model building and simulation proceeds in four stages:

</P>

<OL>
<LI>

You create with any text editor a model description file. The reference
section on <CODE>mod</CODE>, later in this manual gives you the syntax to use
(see section <A HREF="mcsim.html#SEC13">Defining Models</A>). This syntax allows you to describe the
model variables, parameters, equations, inputs and outputs in a C-like
fashion without having you to actually know how to write a C
program.
<LI>

You instruct the model generator, <CODE>mod</CODE>, to preprocess your model
description file. <CODE>Mod</CODE> creates a C file, called <TT>`model.c'</TT>.
<LI>

You compile and link the newly created <TT>`model.c'</TT> file together with
the other C program files. MCSim C code is standard, so you should be
able to compile it with any standard C compiler, for example GNU
<CODE>gcc</CODE>.  After compiling and linking, an executable simulation
program <TT>`mcsim'</TT> is created, specific of the particular model you have
designed. These preprocessing and compilation steps may seem clumsy but
they produce the most efficient code for your particular machine.
<LI>

You design any number of simulation specification files and run them
with the <CODE>mcsim</CODE> program. The simulation specification files describe
the kind of simulation to run (simple simulations, Monte Carlo etc.),
various settings for the integration algorithm if needed, and a
description of one or several experimental conditions or observations to
simulate (see section <A HREF="mcsim.html#SEC25">Specifying Simulations</A>). The simulation output is
written to standard ASCII files.
</OL>

<P>
Little or no knowledge of computer programming is required, unless you
want to tailor the program to special needs, beyond what is described in
this manual (in which case you should contact us). You need, however,
some familiarity with program compilation under your operating system
(see section <A HREF="mcsim.html#SEC8">Installation</A>). The software manual for your
compiler should be able to help you.
</P>



<H2><A NAME="SEC6" HREF="mcsim.html#TOC6">Types of simulations</A></H2>

<P>
Four types of simulations are available:

</P>

<UL>
<LI>

<A NAME="IDX4"></A>
A <STRONG>DefaultSim</STRONG> simulation will simply solve (eventually integrate)
the equations you specified, using the default parameter values and
possible overridings imposed in a simulation specification file.
User-requested outputs are sent to an output file (see section <A HREF="mcsim.html#SEC29"><CODE>SimType()</CODE> specification</A>).
<LI>

<A NAME="IDX5"></A>
A <STRONG>MonteCarlo</STRONG> simulation will perform repeated (stochastic)
simulations across a randomly sampled region of the model parameter
space (see section <A HREF="mcsim.html#SEC32"><CODE>MonteCarlo()</CODE> specification</A>).
<LI>

<A NAME="IDX6"></A>
<A NAME="IDX7"></A>
A <STRONG>MCMC</STRONG> simulation performs a series of simulations along a Markov
chain in the model parameter space (see section <A HREF="mcsim.html#SEC34"><CODE>MCMC()</CODE> specification</A>). These
are Monte Carlo simulations in which the choice of a new parameter value
is influenced by the current value. They can be used to obtain the
Bayesian posterior distribution of the model parameters, given their
prior distributions (that you specify) and data for which a likelihood
function can be computed. The program handles hierarchical (random
effect) statistical models, such as population pharmacokinetic models
(see section <A HREF="mcsim.html#SEC42">Specifying a statistical model</A>).
<LI>

<A NAME="IDX8"></A>
A <STRONG>SetPoints</STRONG> simulation solves the model for a series of specified
parameter sets, listed in a separate ASCII file (see section <A HREF="mcsim.html#SEC35"><CODE>SetPoints()</CODE> specification</A>). You can create these parameter sets yourself or use the
output of a previous Monte Carlo or MCMC simulation.</UL>



<H2><A NAME="SEC7" HREF="mcsim.html#TOC7">Major changes introduced with version 4.2.0</A></H2>
<P>
<A NAME="IDX9"></A>

</P>


<UL>
<LI>

A new input function, <STRONG>Spikes()</STRONG> is available. It simulates
instantaneous inputs (see section <A HREF="mcsim.html#SEC19">Input functions</A>).
<LI>

Six new distributions are available for Monte Carlo simulations:
<STRONG>InvGamma</STRONG> (inverse-gamma), <STRONG>Piecewise</STRONG>, <STRONG>Normal_v</STRONG>,
<STRONG>LogNormal_v</STRONG>, <STRONG>TruncNormal_v</STRONG>, <STRONG>TruncLogNormal_v</STRONG>
(see section <A HREF="mcsim.html#SEC33"><CODE>Distrib()</CODE> specification</A>).
<LI>

In Monte Carlo simulations, shape parameters of <CODE>Distrib()</CODE>
statements can now reference other sampled parameters
(see section <A HREF="mcsim.html#SEC32"><CODE>MonteCarlo()</CODE> specification</A>).
<LI>

A <STRONG>simTypeFlag</STRONG> option, in the <CODE>MCMC()</CODE> specification, allows
the printing of times, data and predictions for easy checking of the
model fit. It can also be set to switch MCMC sampling from component by
component sampling to vector sampling (see section <A HREF="mcsim.html#SEC34"><CODE>MCMC()</CODE> specification</A>).
</UL>



<H1><A NAME="SEC8" HREF="mcsim.html#TOC8">Installation</A></H1>
<P>
<A NAME="IDX10"></A>

</P>


<H2><A NAME="SEC9" HREF="mcsim.html#TOC9">System requirements</A></H2>

<P>
MCSim is written in ANSI-standard C language. We are distributing the
source code and you should be able to compile it for any system,
provided you have an ANSI C compiler. On a Unix system we recommend that
you install the GNU <CODE>gcc</CODE> compiler (freeware) and the <CODE>make</CODE>
utility (which is in fact standard on most systems). For PC-type
computers we recommend the Unix operating system Linux. For the
Macintosh, you can use version 8.0 (or higher) of Symantec’s Think C
compiler, although other compilers should work.
</P>


<H2><A NAME="SEC10" HREF="mcsim.html#TOC10">Distribution</A></H2>

<P>
MCSim source code is available on Internet through
<TT>`ftp://sparky.berkeley.edu/pub/mcsim'</TT>,
<TT>`http://sparky.berkeley.edu/users/fbois/'</TT>, and
<TT>`http://www.gnu.ai.mit.edu/home.html'</TT>.

</P>


<H2><A NAME="SEC11" HREF="mcsim.html#TOC11">Machine-Specific Installation</A></H2>

<P>
To install on a given machine, download (in binary mode) the distributed
archive file to your machine.directory. Move it to an empty directory of
any name. Decompress the archive with GNU gunzip (<CODE>gunzip
&#60;archive-name.gz&#62;</CODE>). Untar the decompressed archive with tar (<CODE>tar
xf &#60;archive-name&#62;</CODE>; do <CODE>man tar</CODE> for further help). On Macintosh
machines the programme "Stuffit Expander" should be able to both
uncompress and untar the archive. This decompression will create two
directories: <TT>`mod'</TT> and <TT>`sim'</TT>.
</P>
<P>
Move to the <TT>`mod'</TT> directory. Under Unix, compile the <CODE>mod</CODE>
program using the <TT>`Makefile'</TT> in that directory (the command
<CODE>make</CODE> should just do that). Under other operating systems, refer
to the documentation of your compiler to create an executable <TT>`mod'</TT>
file from the source code provided in the <TT>`mod'</TT> directory. Move the
executable <TT>`mod'</TT> program you just created to the <TT>`sim'</TT>
directory.
</P>
<P>
You are then ready to use MCSim. This requires creating a model
definition file, processing it with the <CODE>mod</CODE> program, and
compiling the resulting <TT>`model.c'</TT> file with all the other C files
in the <TT>`sim'</TT> directory. You can then run simulations files. We
recommend that you go to the next section of this manual (see section <A HREF="mcsim.html#SEC12">Working Through an Example</A>, which walk you through an example of model building
and running.
</P>
<P>
The makefile <TT>`Test_mcsim'</TT> can be used to test whether the program
output on your Unix machine is the same as the one on our machines. Just
type: <CODE>make; make -f Test_mcsim</CODE> when in your <TT>`sim'</TT> directory.
All input files will be run and their output compared to the
corresponding output files.  You will need to have the <TT>`mod'</TT>
program already compiled and inside the <TT>`sim'</TT> directory, or on the
command path.  In case of differences, don't panic: check the actual
differences between the culprit output file and the file <TT>`sim.out'</TT>
produced by the makefile.  Small differences may occur from different
machine precision.  This can happen for random numbers, in which case
the Markov chain simulations (MCMC) can diverge greatly after a
while.
</P>



<H1><A NAME="SEC12" HREF="mcsim.html#TOC12">Working Through an Example</A></H1>
<P>
<A NAME="IDX11"></A>

</P>
<P>
Pharmacokinetics models describe the transport and transformation of
chemical compounds in the body. These models often include nonlinear
first-order differential equations. The following example is taken from
our own work on the kinetics of tetrachloroethylene (a solvent) in the
human body (Bois et al., 1996; Bois et al., 1990) (see section <A HREF="mcsim.html#SEC46">Bibliographic References</A>).  Go to the <TT>`sim'</TT> directory (under Unix) or to the
<TT>`Development'</TT> folder (on a Macintosh).  Open the file
<TT>`perc.model'</TT> with any text editor (<I>e.g.</I>, <CODE>emacs</CODE> or
<CODE>vi</CODE> under Unix).  This file is distributed as an example of a
model definition file (see section <A HREF="mcsim.html#SEC52"><TT>`perc.model'</TT>: A sample model description file</A>). You can use it as a template
for your own model, but you should leave it unchanged for now. Notice
that it defines:
</P>

<UL>
<LI>

state variables for the model (for which differentials are
defined), for example:

<PRE>
States = {Q_fat,        # Quantity of PERC in the fat
          Q_wp,         #   ...   in the well-perfused compartment
          Q_pp,         #   ...   in the poorly-perfused compartment
          Q_liv,        #   ...   in the liver
          Q_exh,        #   ...   exhaled
          Qmet}         # Quantity of metabolite formed
</PRE>

<LI>

output variables (obtainable at any time as analytical functions
of the states, inputs and parameters), for example:

<PRE>
Outputs = {C_liv,           # mg/l in the liver
           C_alv,           # ... in the alveolar air
           C_exh,           # ... in the exhaled air
           C_ven,           # ... in the venous blood
           Pct_metabolized, # % of the dose metabolized
           C_exh_ug}        # ug/l in the exhaled air
</PRE>

<LI>

input variables (independent of the others variables, and
eventually varying with time), for example:

<PRE>
Inputs = {C_inh} # Concentration inhaled
</PRE>

<LI>

model parameters (independent of time), such as: 


<PRE>
LeanBodyWt = 55; # lean body weight
</PRE>

<LI>

system's dynamics (differential or algebraic equations defining the 
model <I>per se</I>),
<LI>

parameters' scaling (the parameters used in the equations can be
made functions of other parameters: for example volumes can be computed
from masses and densities),
<LI>

equations to compute the output variables.

</UL>

<P>
This model definition file as a simple syntax, easy to master. It needs
to be turned into a C program file before compilation and linking to the
other routines (integration, file management etc.) of MCSim. You will
use <CODE>mod</CODE> for that. First, quit the editor and return to the operating
system.

</P>
<P>
To start <CODE>mod</CODE> under Unix just type <CODE>mod perc.model</CODE>. On a
Macintosh, double click the <TT>`Mod'</TT> icon; <CODE>Mod</CODE> prompts you for
the name of your model definition file; Type <TT>`perc.model'</TT>. After a
few seconds, with no error messages if the model definition is
syntactically correct, <CODE>Mod</CODE> announces that the <TT>`model.c'</TT> file
has been generated. On a Macintosh you need to hit the return key to
exit <CODE>Mod</CODE>.
</P>
<P>
The next step is to compile and link together the various C files that
will constitute the simulation program for your particular model. Note
that each time you want to change an equation in your model you will
have to change the model definition file and repeat the steps above.
However, changing just parameter values or state initial values does not
require recompilation since that can be done through simulation
specification files.

</P>

<UL>
<LI>

Under Unix, the simplest is to use the <CODE>make</CODE> utility. Just type
<CODE>make</CODE> and compilation will be done automatically (see section <A HREF="mcsim.html#SEC48">Using <CODE>make</CODE></A>). An executable <TT>`mcsim'</TT> is created. You can rename it to
better describe the fact that it is model specific: rename it
<TT>`mcsim_perc'</TT>, for example.
<LI>

On a Macintosh, or PC, the best is to use a Think C project or a similar
programming environment.  You should first use the command <CODE>make</CODE>
or its equivalent to compile the modified <TT>`model.c'</TT> file and other
C files. Then create an application (you should give it a name specific
to the model you are developing, <I>e.g.</I>, <TT>`MCSim Perc'</TT>). Refer to
your compiler manual for details on how to use your programming
environment.  Your executable <TT>`MCSim Perc'</TT> program is now ready to
perform simulations.
</UL>

<P>
To start your MCSim program just type <CODE>mcsim_perc</CODE> (if you gave it
that name) under Unix, or double click the <TT>`MCSim Perc'</TT> – or
whatever name you specified – icon on your Macintosh. After an
introductory banner (telling in particular which model file the program
has been compiled with), you are prompted for an input file name: type
<KBD>perc.lsodes.in</KBD> (see section <A HREF="mcsim.html#SEC53"><TT>`perc.lsodes.in'</TT></A>, to see this file now). The
program then prompts you for the output file name: type
<KBD>perc.lsodes.out</KBD>. After a few seconds or less (depending on your
machine) the program announces that it has finished and that the output
file is <TT>`perc.lsodes.out'</TT> (on a Macintosh you should hit the return
key to exit the program completely).  You can open the output file with
any text editor or word processor, you can edit it for input in graphic
programs etc.
</P>
<P>
Several other models and simulation specification files are provided
with the package as examples (they are in the <TT>`sim'</TT> directory.  Try
them and observe the output you obtain. You can then start programming
you own models and doing simulations. The next sections of this manual
reference the syntax for model definition and simulation
specifications.
</P>



<H1><A NAME="SEC13" HREF="mcsim.html#TOC13">Defining Models</A></H1>
<P>
<A NAME="IDX12"></A>
<A NAME="IDX13"></A>

</P>

<P>
<A NAME="IDX14"></A>
Three examples of model simulation files: <TT>`linear.model'</TT>,
<TT>`1cpt.model'</TT> and <TT>`perc.model'</TT> are included with the program
files and appears in Appendix of this manual (see section <A HREF="mcsim.html#SEC49">Examples</A>).
</P>



<H2><A NAME="SEC14" HREF="mcsim.html#TOC14">Using Mod to process model description files</A></H2>
<P>
<A NAME="IDX15"></A>

</P>
<P>
The <CODE>mod</CODE> program is a stand-alone facility. It takes a model
description file in the "user-friendly" format described below and
creates a C language file <TT>`model.c'</TT> which you will compile and link
to the simulation program. <CODE>Mod</CODE> allows the user to define
equations for the model, assign default values to parameters or default
initial values to model variables, and define scaling functions for both
the input parameters and the outputs variables. <CODE>Mod</CODE> lets the user
create and modify models without having to maintain C code.
</P>
<P>
In Unix, the command line syntax for the mod program is:

</P>

<PRE>
mod [input-file [output-file]]
</PRE>

<P>
where the brackets indicate that the input and output filenames are
optional. If the input filename is not specified, the program will
prompt for both. If only the input filename is specified, the output is
written by default to the file <TT>`model.c'</TT>. Unless you feel like doing
some makefile programming, we recommend using this default since the
makefile for MCSim assumes the C language model file to have this name. You
have to have prepared an input file containing a description of the
model following the syntax described in the following (see section <A HREF="mcsim.html#SEC15">Syntax of the model description file</A>).
</P>
<P>
On the Macintosh you double-click the <TT>`Mod'</TT> icon and enter the name
of the model definition file at the prompt (on the Macintosh, names can
include space characters).
</P>



<H2><A NAME="SEC15" HREF="mcsim.html#TOC15">Syntax of the model description file</A></H2>
<P>
<A NAME="IDX16"></A>
<A NAME="IDX17"></A>

</P>

<P>
The model description file is a text (ASCII) file that consists of
several sections, including global declarations, dynamics specifications
(eventually with derivative calculations), model scaling, and output
computations:
</P>

<PRE>
# Model description file (this is a comment)
&#60;Global parameter specifications&#62;
Dynamics {
  &#60;Equations for calculating the dynamics, or state derivatives&#62;
}
Scale {
  &#60;Equations for scaling model parameters&#62;
}
CalcOutputs {
  &#60;Equations for scaling the outputs&#62;
}
</PRE>

<P>
where <STRONG>Dynamics</STRONG>, <STRONG>Scale</STRONG> and <STRONG>CalcOutputs</STRONG> are keywords
and, if used, must appear as shown, followed by the curly braces which
delimit the section.  At least one of the sections <CODE>Dynamics</CODE> or
<CODE>CalcOutputs</CODE> should be defined.  <CODE>Dynamics</CODE> must be used if
the model includes differential equations.
</P>



<H3><A NAME="SEC16" HREF="mcsim.html#TOC16">General syntax</A></H3>

<P>
The general syntax of the file is as follows:

</P>

<UL>
<LI>

<A NAME="IDX18"></A>
<A NAME="IDX19"></A>
Comments begin with a pound sign (<KBD>#</KBD>) and continue to the end of
the line.
<LI>

<A NAME="IDX20"></A>
Blank lines are allowed and ignored.
<LI>

<A NAME="IDX21"></A>
<A NAME="IDX22"></A>
All commands can span several lines and are terminated by a semi-colon
(<KBD>;</KBD>). There should be no blank space before the semi-colon.
<LI>

<A NAME="IDX23"></A>
Variable assignments have the following syntax:


<PRE>
var-name '=' constant-value-or-expression ';'
</PRE>

where var-name is any valid C identifier, starting with a letter or
underscore (<KBD>_</KBD>) and followed by any number of alpha-numeric
characters or underscores, up to a maximum of 80. Variable names are
case sensitive.  Note that the name <KBD>IFN</KBD>, in capital letters, is
reserved by the program and should not be used as parameter or variable
name. The equal sign is needed. The right-hand side expression can be a
valid C mathematical expression including already defined variables and
ANSI C mathematical functions.  Additional functions, called special
functions, can be used, which take variable names, constant values or
expressions as parameters. Special functions are detailed below
(see section <A HREF="mcsim.html#SEC18">Special functions</A>). Finally, there should be no space before
the terminating semi-colon.
Colon conditional assignments can also be used. Syntax:
<A NAME="IDX24"></A>
<A NAME="IDX25"></A>


<PRE>
var-name '=' (&#60;condition&#62; ? &#60;value-if-true&#62; : &#60;value-if-false&#62;);
</PRE>

For example:


<PRE>
Adj_Parm = (Input &#62; 0.0 ? Parm * Adjust : Parm);
</PRE>

In this example, if <SAMP>`Input'</SAMP> is greater than 0, the parameter
<SAMP>`Adj_Parm'</SAMP> is computed as the product of <SAMP>`Parm'</SAMP> by
<SAMP>`Adjust'</SAMP>; otherwise <SAMP>`Adj_Parm'</SAMP> is equal to <SAMP>`Parm'</SAMP>.  The
comparison operators allowed are the equality operator <CODE>==</CODE>, and
non-equality operators <CODE>!=</CODE>, <CODE>&#60;</CODE>, <CODE>&#62;</CODE>, <CODE>&#60;&#62;</CODE>,
<CODE>&#60;=</CODE> and <CODE>&#62;=</CODE>.<A NAME="IDX26"></A>
</UL>



<H3><A NAME="SEC17" HREF="mcsim.html#TOC17">Global parameter declarations</A></H3>
<P>
<A NAME="IDX27"></A>

</P>
<P>
Commands not specified within the delimiting braces of another section
are considered to be global declarations. In the global section, you
first declare the states, inputs, and outputs variables. There should be
at least one state or output variable in your model.
</P>

<UL>
<LI>

<A NAME="IDX28"></A>
States are variables for which a first-order differential equation is
defined (higher orders or partial differential equations are not
allowed).
<LI>

<A NAME="IDX29"></A>
Inputs are variables independent of the others variables, but eventually
varying with time (for example an exposure concentration to a
chemical).
<LI>

<A NAME="IDX30"></A>
Outputs are dependent model variables (obtainable at any time as
analytical functions of the states, inputs or parameters) that do not
have dynamics.</UL>

<P>
The format for declaring each of these variables is the same, and
consists of the keyword <STRONG>States</STRONG>, <STRONG>Inputs</STRONG> or <STRONG>Outputs</STRONG>
followed by a list of the variable names enclosed in curly braces as
shown here:

</P>

<PRE>
States =   {Qb_fat,  # Benzene in the fat
            Qb_bm,   # ...     in the bone marrow
            Qb_liv}; # ...     in the liver and others

Inputs =   {Q_gav,   # Gavage dose
            C_inh};  # Inhalation concentration

Outputs =  {Cb_exp,  # Concentration in expired air
            Cb_ven}; # ...           in venous blood
</PRE>

<P>
After being defined, states, inputs and outputs can then be given
initial values (constants or expressions). Note that inputs can also be
assigned input functions, described below. Some examples of
initialization are shown here:

</P>

<PRE>
Qb_fat = 0.1; # Default initial value for state variable Qb_fat

# Gavage input assigned a periodic exponential input function
Q_gav = PerExp(1, 60, 0, 1); # Magnitude of 1.0,
                             # period of 60 time units,
                             # T0 in period is 0,
                             # Rate constant is 1.0
</PRE>

<P>
If a global state, input, or output variable is not given an initial
value, it will default to zero. Initial values are reset to their
specified value by the simulation program at the start of each
simulation of an <CODE>Experiment</CODE> (see section <A HREF="mcsim.html#SEC37"><CODE>Experiment</CODE> definition</A>).
</P>
<P>
All the model parameters you want to be able to change through
simulation files should be declared global.  Parameters must be given
nominal values, following the assignment rules given above. For
example:
</P>

<PRE>
BodyWt = 0.38 + sqrt(0.01); # (kg) Weight of the rat
</PRE>

<P>
All parameters and variables are computed in double precision
floating-point numbers. Initialization values should not be such as to
cause computation errors in the model equations; this is likely to cause
program crashes (so, for example, do not assign a default value of zero
to a parameter appearing alone in a denominator). Note that the order of
global declarations matters within the global section itself (<I>i.e.</I>,
parameters and variables should be defined and initialized before being
used in assignments of others), but not with respect to other blocks. A
parameter defined at the end of the description file can be used in the
dynamics section which may appear at the beginning of the file. Still,
such an inverse order should be avoided. For this reason, the format
above, where global declarations come first, is strongly suggested to
avoid confusing results. Note again that the name <CODE>IFN</CODE>, in capital
letters, is reserved by the program and should not be used as parameter
or variable name.  Finally, if a parameter is defined several times,
only the first definition is taken into account.
</P>



<H3><A NAME="SEC18" HREF="mcsim.html#TOC18">Special functions</A></H3>
<P>
<A NAME="IDX31"></A>
<A NAME="IDX32"></A>

</P>

<P>
The following special functions (whoe name is case-sensitive) are
available to the user for assignment of parameters and variables in the
model definition file:

</P>

<UL>
<LI>

<A NAME="IDX33"></A>
<A NAME="IDX34"></A>
<A NAME="IDX35"></A>
<A NAME="IDX36"></A>
<STRONG>CDFNormal(<VAR>x</VAR>)</STRONG>: the normal cumulative density function;

<LI>

<A NAME="IDX37"></A>
<A NAME="IDX38"></A>
<A NAME="IDX39"></A>
<STRONG>erfc(<VAR>x</VAR>)</STRONG>: the error function;

<LI>

<A NAME="IDX40"></A>
<A NAME="IDX41"></A>
<A NAME="IDX42"></A>
<A NAME="IDX43"></A>
<STRONG>lnDFNormal(<VAR>x</VAR>, <VAR>mean</VAR>, <VAR>sd</VAR>)</STRONG>: the natural logarithm
of the normal density function;
<LI>

<A NAME="IDX44"></A>
<A NAME="IDX45"></A>
<A NAME="IDX46"></A>
<STRONG>lnGamma(<VAR>x</VAR>)</STRONG>: the natural logarithm of the gamma function;

<LI>

<A NAME="IDX47"></A>
<A NAME="IDX48"></A>
<A NAME="IDX49"></A>
<STRONG>UniformRandom(<VAR>min</VAR>, <VAR>max</VAR>)</STRONG>: returns a uniformly
distributed random variable, sampled between min and max. The algorithm
used is that of Park and Miller (Barry, 1996; Park and Miller, 1988;
Vattulainen et al., 1994) (see section <A HREF="mcsim.html#SEC46">Bibliographic References</A>). A default
random generator seed (314159265.3589793) is used;
<LI>

<A NAME="IDX50"></A>
<A NAME="IDX51"></A>
<A NAME="IDX52"></A>
<STRONG>NormalRandom(<VAR>mean</VAR>, <VAR>sd</VAR>)</STRONG>: returns a normally distributed
random variable.  The default random generator seed is used.</UL>



<H3><A NAME="SEC19" HREF="mcsim.html#TOC19">Input functions</A></H3>
<P>
<A NAME="IDX53"></A>
<A NAME="IDX54"></A>

</P>

<P>
They can be used in a special  assignments, valid only for input
variables. Inputs can be initialized as a constant or expression, or
assigned one of the following input functions:
</P>

<UL>
<LI>

<A NAME="IDX55"></A>
<A NAME="IDX56"></A>
<STRONG>PerDose()</STRONG> specifies a periodic input of constant <VAR>magnitude</VAR>.
The input begins at <VAR>initial-time</VAR> in the <VAR>period</VAR> and lasts for
<VAR>exposure-time</VAR> time units. Syntax:

<PRE>
PerDose(&#60;magnitude&#62;, &#60;period&#62;, &#60;initial-time&#62;, &#60;exposure-time&#62;);
</PRE>

<LI>

<A NAME="IDX57"></A>
<A NAME="IDX58"></A>
<STRONG>PerExp()</STRONG> specifies a periodic exponential input. At time
<VAR>initial-time</VAR> in the <VAR>period</VAR> the input rises instantaneously
to <VAR>magnitude</VAR> and begins to decay exponentially with the constant
<VAR>decay-constant</VAR>. The input is turned off once the magnitude reaches
a negligible fraction 
of its original value.
Syntax:

<PRE>
PerExp(&#60;magnitude&#62;, &#60;period&#62;, &#60;initial-time&#62;, &#60;decay-constant&#62;);
</PRE>

<LI>

<A NAME="IDX59"></A>
<A NAME="IDX60"></A>
<STRONG>NDoses()</STRONG> specifies a number of stepwise inputs of variable
magnitude and their starting times. The first argument, <VAR>n</VAR>, is the
number of input steps and start times. Next come a list of magnitudes
and a list of initial times. Each list is comma-separated.  The duration
of input step is computed automatically by difference between the
specified times. Currently this function can only be used in the
simulation description file, and not in the model description file
(which simply implies that you cannot use it as a default).
Syntax:

<PRE>
NDoses(&#60;n&#62;, &#60;list-of-magnitudes&#62;, &#60;list-of-initial-times&#62;);
</PRE>

<LI>

<A NAME="IDX61"></A>
<A NAME="IDX62"></A>
<STRONG>Spikes()</STRONG> specifies a number of instantaneous inputs of variable
magnitude and their exact times of occurence. The first argument,
<VAR>n</VAR>, is the number of inputs and input times. Next come a list of
magnitudes and a list of times. Each list is comma-separated.
Currently this function can only be used in the simulation description
file, and not in the model description file (which simply implies that
you cannot use it as a default). Syntax:

<PRE>
Spikes(&#60;n&#62;, &#60;list-of-magnitudes&#62;, &#60;list-of-times&#62;);
</PRE>

</UL>

<P>
The arguments of input functions can either be constants or variables.
As an example, if <SAMP>`GavMag'</SAMP> and <SAMP>`RateConst'</SAMP> are defined model
parameters, then the input variable <SAMP>`Q_gav'</SAMP> can be defined
as:
</P>

<PRE>
Q_gav = PerExp(GavMag, 60, 0, RateConst);
</PRE>

<P>
In this way the parameters of input functions can, for example, be
assigned statistical distributions in Monte Carlo simulations
(see section <A HREF="mcsim.html#SEC33"><CODE>Distrib()</CODE> specification</A>).
</P>
<P>
Variable dependencies are resolved before the simulation is started. For
each of the periodic functions, a single exposure beginning at time
<VAR>initial-time</VAR> can be specified by giving an effectively infinite
period,
The first period starts at the initial time of the simulation.
Magnitudes change exactly at the times given.
</P>
<P>
Input functions can be combined to give a lot of flexibility (<I>e.g.</I>,
an input can be sum of some others). Separate inputs can be declared in
the global section of the model definition file and combined in the
<CODE>Dynamics</CODE> and <CODE>CalcOutputs</CODE> sections. The only limitation is
that for each input function used, a separate input must be defined in
the model, even though this function may not be a real element of the
model.
</P>



<H3><A NAME="SEC20" HREF="mcsim.html#TOC20">Dynamics specifications</A></H3>
<P>
<A NAME="IDX63"></A>

</P>

<P>
The dynamics specification section begins with the keyword
<STRONG>Dynamics</STRONG> and is enclosed in curly braces. The equations given in
this section will be called by the integrator at each integration
step.
</P>
<P>
Additional variables to those declared in the global section may be used
for any calculations within the section. They will be declared as local
temporary variables. (Note, for example, the use of <SAMP>`Cout_fat'</SAMP> and
<SAMP>`Cout_wp'</SAMP> in the <TT>`perc.model'</TT> sample file). Local variables
are not accessible from the simulation program, or from other sections
of the model definition file, so don't try to output them.
</P>
<P>
Each state variable declared in the global section must have one
corresponding state equation in the <CODE>Dynamics</CODE> section. If a state
equation is missing, <CODE>mod</CODE> issues an error message such as:
</P>

<PRE>
Error: State variable 'Q_foo' has no dynamics.
</PRE>

<P>
If one or more differential equations are missing, no program file will
be created. Most error messages are self-explanatory. Where appropriate,
they also show a line number in the input file where the error occurred.
Beware, however, of cascades of errors generated as a consequence of a
first one; so don't panic: start by fixing the first one and rerun
<CODE>mod</CODE>.
</P>
<P>
<A NAME="IDX64"></A>
<A NAME="IDX65"></A>
The derivative of a state variable is defined using the <STRONG>dt()</STRONG>
operator, as shown here:
</P>

<PRE>
dt(state-variable) '=' constant-value-or-expression ';'
</PRE>

<P>
The right-hand side can be any valid C expression, including standard
math library calls and the special functions mentioned above
(see section <A HREF="mcsim.html#SEC18">Special functions</A>). Note, however, that no syntactic check is
performed on the library function calls. Their correctness is your
responsibility.
</P>
<P>
The <CODE>dt()</CODE> operator can also be used in the right-hand side of
equations in the dynamics section to refer to the value of a derivative
at that point in the calculations. For example:

</P>

<PRE>
dt(Qm_in) = Qmetabolized - dt(Qm_out);
</PRE>

<P>
<A NAME="IDX66"></A>
The integration variable (<I>e.g.</I>, time) can be accessed if referred
to as <CODE>t</CODE>, as in:
</P>

<PRE>
dt(Qm_in) = Qmetabolized - t;
</PRE>

<P>
Output variables can also be made a function of <CODE>t</CODE> in the
<CODE>Dynamics</CODE> section.
</P>
<P>
Note that while state variables, input variables and model parameters
can indeed be used on the right-hand side of equations, they cannot be
assigned values in the <CODE>Dynamics</CODE> section. If you need a parameter
to change with time, declare it as output variable in the global
section. Assignments to inputs or parameters in this section causes an
error message like the following to be issued:
</P>

<PRE>
Error: line 48: 'YourParm' used in invalid context.
Parameters cannot be defined in Dynamics{} section.
</PRE>



<H3><A NAME="SEC21" HREF="mcsim.html#TOC21">Parameter scaling</A></H3>
<P>
<A NAME="IDX67"></A>
<A NAME="IDX68"></A>

</P>

<P>
The parameter scaling section begins with the keyword <STRONG>Scale</STRONG> and is
enclosed in curly braces. The equations given in this section will
define a function that will be called by the simulation program at the
beginning of each simulation of an <CODE>Experiment</CODE> (see section <A HREF="mcsim.html#SEC37"><CODE>Experiment</CODE> definition</A>). They can therefore be used for initialization of the
simulations.
</P>
<P>
All model variables and parameters can be changed in this section.
Modifications to state variables affect initial values only. Modifying
an input is not allowed and state variables can only appear at the left
hand side of equations.
</P>
<P>
The <CODE>dt()</CODE> operator (see section <A HREF="mcsim.html#SEC20">Dynamics specifications</A>) cannot be
used in this section, since derivatives have not yet been computed when
the scaling function is called.
</P>



<H3><A NAME="SEC22" HREF="mcsim.html#TOC22">Output calculations</A></H3>
<P>
<A NAME="IDX69"></A>
<A NAME="IDX70"></A>

</P>

<P>
The output calculation section begins with the keyword <STRONG>CalcOutputs</STRONG>
and is enclosed in curly braces. The equations given in this section
will be called by the simulation program at each output time specified
by a <CODE>Print()</CODE> or <CODE>PrintStep()</CODE> statement (see section <A HREF="mcsim.html#SEC39"><CODE>Print()</CODE> specification</A>, and see section <A HREF="mcsim.html#SEC40"><CODE>PrintStep()</CODE> specification</A>). In this way, the
output scaling is done efficiently, only when values are to be saved,
and not at each integration step.
</P>
<P>
Only variables that have been declared with the keyword <CODE>Outputs</CODE>
can be changed in this section.
</P>
<P>
Assignments to other types of variables cause an error message like the
following to be issued:

</P>

<PRE>
Error: line 56: 'Qb_fat' used in invalid context.
Only outputs can be defined in CalcOutputs{} section.
</PRE>

<P>
Any reference to an input or state variable will use the last calculated
(current) value of the input. The <CODE>dt()</CODE> operator can appear in the
right-hand side of equations, and it refers to values of the derivative
as calculated at the last time step (see section <A HREF="mcsim.html#SEC20">Dynamics specifications</A>).
Like in the <CODE>Dynamics</CODE> section, the integration variable can be
accessed if referred to as <CODE>t</CODE>, as in:
</P>

<PRE>
Qx_out = DQx * t;
</PRE>



<H3><A NAME="SEC23" HREF="mcsim.html#TOC23">Comments on style</A></H3>
<P>
<A NAME="IDX71"></A>

</P>

<P>
For your model file to be readable and understandable, it is useful to
use a consistent style of notation. The example file <TT>`perc.model'</TT>
follows such a consistent notation (see section <A HREF="mcsim.html#SEC52"><TT>`perc.model'</TT>: A sample model description file</A>). For example we
suggest that:
</P>

<UL>
<LI>

All variable names begin with a capital letter followed by meaningful
lower case subscripts.
<LI>

Where two subscripts are necessary, they can be separated by an
underscore, such as in <SAMP>`Qb_fat'</SAMP>.
<LI>

Where there is only one subscript an underscore can still be used to
increase readability as in <SAMP>`Q_fat'</SAMP>.
<LI>

Where two words are used in combination to name one item, they can be
separated visually by capitalizing each word, as in <SAMP>`BodyWt'</SAMP>.</UL>

<P>
These conventions are suggestions only. The key to have a consistent
notation that makes sense to you. Consistency is one of the best ways
to:

</P>

<OL>
<LI>

Increase readability, both for others and for yourself. If you
have to suspend work for a month or two and then come back to it, the
last thing you want is to have to decipher your own file.

<LI>

Decrease the likelihood of mistakes. If all of the equations are
coded with a consistent, logical convention, mistakes stand out more
readily.
</OL>



<H3><A NAME="SEC24" HREF="mcsim.html#TOC24">Note about models</A></H3>
<P>
<A NAME="IDX72"></A>

</P>

<P>
MCSim can easily deal with algebraic models. You do not need to define
state variables or a <CODE>Dynamics</CODE> section for such models. Simply use
input and output variables and paramaters. The model can be specified in
the <CODE>CalcOutputs</CODE> section. You can use the time <CODE>t</CODE> if that is
natural for your model. If you do not use <CODE>t</CODE> in your model, you
will still need to specify "output times" in <CODE>Print()</CODE> or
<CODE>PrintStep()</CODE> statements to obtain outputs: you can use an
arbitrary time, such as 1. If you do not use <CODE>t</CODE> you will also need
do define an <CODE>Experiment</CODE> (see section <A HREF="mcsim.html#SEC37"><CODE>Experiment</CODE> definition</A>) for each
combination of values for the "independent" variables of your model.
This may be clumsy if many values are to be used. In that case, you may
want to use the variable <CODE>t</CODE> to represent something else than
time.
</P>
<P>
Ordinary differential models, with algebraic components, can be setup easily 
with MCSim. Use state variables and specify a <CODE>Dynamics</CODE> section. Time,
<CODE>t</CODE> is the integration variable, but here again, <CODE>t</CODE> can be used
to represent anything you want. We are not aware of cases in which MCSim
has been used for partial differential equations. Some problems might be
solved by implementing rudimentary line methods...
</P>
<P>
You can use MCSim for discrete-time dynamic models (or difference
models).  It's a bit tricky. Assignments in <CODE>CalcOutput</CODE> are
volatile (not memorized), so the model equations have to be in
<CODE>Dynamics</CODE>. But the model variables should still be declared as
outputs, because they should not be updated by integration. However, you
need at least a true state in the <CODE>Dynamics</CODE> section, so you should
declare a dummy one (and give it a constant derivative of value zero).
You also want the calls to <CODE>Dynamics</CODE> to be precisely scheduled, so
it is best to use the <CODE>Euler</CODE> integration routine
(see section <A HREF="mcsim.html#SEC30"><CODE>Integrate()</CODE> specification</A>) which uses a constant step. Since
Euler may call repeatedly <CODE>Dynamics</CODE> at any given time, you want to
guard against untimely updating... Altogether, we recommend that you
examine the sample files <TT>`discrete.model'</TT> and <TT>`discrete.in'</TT>
provided with the source code for MCSim.
</P>



<H1><A NAME="SEC25" HREF="mcsim.html#TOC25">Specifying Simulations</A></H1>
<P>
<A NAME="IDX73"></A>
<A NAME="IDX74"></A>

</P>

<P>
After having your model defined and processed by <CODE>mod</CODE>, and the
resulting <TT>`model.c'</TT> file compiled with the MCSim routines, you are
ready to run simulations. For this you need to write a simulation
file.
</P>
<P>
An example file <TT>`perc.lsodes.in'</TT>, which works with the
perchloroethylene model, appears in Appendix
(see section <A HREF="mcsim.html#SEC53"><TT>`perc.lsodes.in'</TT></A>).
</P>



<H2><A NAME="SEC26" HREF="mcsim.html#TOC26">Using the compiled program</A></H2>

<P>
The simulation environment MCSim provides several types of simulations
for the models you create. Simulations are specified in a text file of
format similar to that of the model description file.

</P>
<P>
In Unix the command-line syntax for the MCSim program is:

</P>

<PRE>
mcsim [input-file [output-file]]
</PRE>

<P>
where the brackets indicate optional arguments. This assume that you
have not renamed the executable file; If you have, substitute the name
of your executable. If no input and output file names are specified, the
program will prompt you for them. If already one file name is given on
the command-line, the program will assume it specifies the input file
and will prompt you for the output file name. You must provide an input
file name. If you just hit the return key when prompted for the output
name, the program will use the name you have specified in the input
file, if any, or a default name. When the program starts up, it
announces which model description file it was created with. The input
file describes the simulations to perform and specifies which outputs
should be printed out (see section <A HREF="mcsim.html#SEC27">Syntax of the simulation definition file</A>).
</P>
<P>
On the Macintosh you double-click the <TT>`MCSim'</TT> icon and enter the
name of your simulation definition file at the first prompt and then the
name of the output file (or just hit return if you want the default or
the name you have specified in the input file to be used).
</P>



<H2><A NAME="SEC27" HREF="mcsim.html#TOC27">Syntax of the simulation definition file</A></H2>
<P>
<A NAME="IDX75"></A>
<A NAME="IDX76"></A>

</P>
<P>
The file starts with a global declaration section followed by a number
of <STRONG>Experiment</STRONG> (<I>i.e.</I>, simulation) definitions
(see section <A HREF="mcsim.html#SEC37"><CODE>Experiment</CODE> definition</A>), eventually enclosed in a <STRONG>Level</STRONG>
definition if Markov chain Monte Carlo simulations are to be performed
(see section <A HREF="mcsim.html#SEC42">Specifying a statistical model</A>). Each <CODE>Experiment</CODE> defines
simulation conditions, from an initial time (or whatever your dependent
variable represents) to a final time. The initial values of model state
variables, parameter values, input variables, and which outputs are to
print at which times can all be changed in a given
<CODE>Experiment</CODE>.
</P>
<P>
The general syntax of the file is the same as that of <CODE>mod</CODE> with
two differences:
</P>

<UL>
<LI>

Variables can only be assigned constant values.

<LI>

Input variables' assignments can use any input function (including the
<CODE>NDoses()</CODE> function) or constant values.</UL>

<P>
Expressions are not allowed (unlike in the model definition file where
they can be used). Similarly, structural change to the model, for
instance, addition of a state, input, output or parameter, cannot be
done here and must be done in the model description file. The simulation
specification file is read until its end is reached, or until an
<CODE>End</CODE> command is reached.
</P>
<P>
The general layout of the file is:

</P>

<PRE>
# Input file (this a comment)
&#60;Global modifications and analysis specifications&#62;
Experiment {
  &#60;Specifications for first experiment&#62;
}
Experiment {
  &#60;Specifications for second experiment&#62;
}
# Unlimited number of experiment specifications
End # Optional End statement. Everything after this line is ignored
</PRE>

<P>
For Markov chain Monte Carlo simulations (see section <A HREF="mcsim.html#SEC34"><CODE>MCMC()</CODE> specification</A>),
the general layout of the file includes <CODE>Level</CODE> definitions:
</P>

<PRE>
# Input file (this is a comment)
SimType(MCMC);
&#60;Global modifications and analysis specifications&#62;
Level {
  # Up to 10 levels of hierarchy
  Experiment {
    Specifications for first experiment
  }
  Experiment {
    Specifications for second experiment
  }
  # Unlimited number of experiment specifications
} # end Level
End # Optional statement. Everything after this line is ignored
</PRE>



<H2><A NAME="SEC28" HREF="mcsim.html#TOC28">Global specifications</A></H2>
<P>
<A NAME="IDX77"></A>

</P>
<P>
The global section is used to give specifications relevant to all
experiments, for example specification of the type of analysis, how the
integrator should work, parameter modifications to be used for all
experiments, etc.

</P>
<P>
Both the global section and each experiment section can contain
modifications to defined model variables. At the beginning of a
simulation, all model parameters are initialized to the nominal values
specified in the model description file. Next, modifications given in
the global section are applied, and finally any modifications for the
current experiment are applied.

</P>



<H3><A NAME="SEC29" HREF="mcsim.html#TOC29"><CODE>SimType()</CODE> specification</A></H3>
<P>
<A NAME="IDX78"></A>
<A NAME="IDX79"></A>

</P>
<P>
The type of analysis performed is specified using the <STRONG>SimType()</STRONG>
specification. Example:

</P>

<PRE>
SimType(MonteCarlo);
</PRE>

<P>
The following keywords can be used: 

</P>

<UL>
<LI>

<STRONG>DefaultSim</STRONG>: the list of specified experiments is simulated,

<LI>

<STRONG>MonteCarlo</STRONG>: the specified experiments are simulated several times
with random input parameters (see section <A HREF="mcsim.html#SEC32"><CODE>MonteCarlo()</CODE> specification</A>),
<LI>

<STRONG>MCMC</STRONG> (previously <CODE>Gibbs</CODE>): Markov chain Monte Carlo
simulations are performed to attain the posterior distribution of the
model's parameters, given their prior distributions 
and data for which the likelihood function can be computed
(see section <A HREF="mcsim.html#SEC34"><CODE>MCMC()</CODE> specification</A>),
<LI>

<STRONG>SetPoints</STRONG>: the experiments are simulated using several lists of
user-defined parameters values in input (see section <A HREF="mcsim.html#SEC35"><CODE>SetPoints()</CODE> specification</A>).</UL>

<P>
If <CODE>MonteCarlo</CODE>, <CODE>MCMC</CODE>, or <CODE>SetPoints</CODE> simulations are
requested, additional specifications are needed (see below).
</P>



<H3><A NAME="SEC30" HREF="mcsim.html#TOC30"><CODE>Integrate()</CODE> specification</A></H3>
<P>
<A NAME="IDX80"></A>
<A NAME="IDX81"></A>
<A NAME="IDX82"></A>
<A NAME="IDX83"></A>
<A NAME="IDX84"></A>
<A NAME="IDX85"></A>

</P>

<P>
The integrator settings can be changed with the <STRONG>Integrate</STRONG>
specification.  Two integration routines are provided: <STRONG>Lsodes</STRONG>
(which originates from the SLAC Fortran library and is originally based
on Gear's routine) (Gear, 1971b; Gear, 1971a; Press et al., 1989)
(see section <A HREF="mcsim.html#SEC46">Bibliographic References</A>) and <STRONG>Euler</STRONG> (Press et al.,
1989).
</P>

<P>
The syntax for <CODE>Lsodes</CODE> is:

</P>

<PRE>
Integrate(Lsodes, &#60;rtol&#62;, &#60;atol&#62;, &#60;method&#62;);
</PRE>

<P>
<VAR>Rtol</VAR> is a scalar specifying the relative error tolerance for each
integration step. <VAR>Atol</VAR> is a scalar specifying the absolute error
tolerance parameter. They apply to all integration variables (state
variables). The estimated local error in a state variable <VAR>y(i)</VAR>
will be controlled so as to be roughly less (in magnitude) than
Thus the local error test passes if, in each component, either the
absolute error is less than <VAR>atol</VAR>, or the relative error is less
than <VAR>rtol</VAR>. Set <VAR>rtol</VAR> to zero for pure absolute error control,
and use <VAR>atol</VAR> to zero for pure relative error control. Caution:
actual (global) errors may exceed these local tolerances, so choose them
conservatively.  The <VAR>method</VAR> flag should be 0 (zero) for non-stiff
differential systems and 1 for stiff systems. You should try both and
select the fastest for equal accuracy of output, unless insight from
your system leads you to choose <I>a priori</I>. In our experience, a good
starting point for <VAR>atol</VAR> and <VAR>rtol</VAR> is about

</P>

<P>
The syntax for <CODE>Euler</CODE> is:

</P>

<PRE>
Integrate(Euler, &#60;time-step&#62;, 0, 0);
</PRE>

<P>
<VAR>time-step</VAR> is a scalar specifying the constant time-step to be
taken at each integration step. The next two scalars are reserved for
future use and should be set to zero.
</P>

<P>
If the <CODE>Integrate()</CODE> specification is not used, the default integration
method is <CODE>Lsodes</CODE> with parameters
We recommend using <CODE>Lsodes</CODE>, since is it highly accurate and
efficient.  <CODE>Euler</CODE> can be used for special applications (e.g., in
system dynamics) where a constant time step and a simple algorithm are
needed.
</P>



<H3><A NAME="SEC31" HREF="mcsim.html#TOC31"><CODE>OutputFile()</CODE> specification</A></H3>
<P>
<A NAME="IDX86"></A>
<A NAME="IDX87"></A>

</P>
<P>
The <STRONG>OutputFile()</STRONG> specification allows you to specify a name for
the output file of <CODE>DefaultSim</CODE> simulations. If this specification
is not given the name <TT>`sim.out'</TT> is used if none has been supplied
on the command-line or the initial dialog. The corresponding syntax
is:
</P>

<PRE>
OutputFile("&#60;OutputFilename&#62;");
</PRE>



<H3><A NAME="SEC32" HREF="mcsim.html#TOC32"><CODE>MonteCarlo()</CODE> specification</A></H3>
<P>
<A NAME="IDX88"></A>
<A NAME="IDX89"></A>

</P>

<P>
Monte Carlo simulations (Hammersley and Handscomb, 1964; Manteufel,
1996) (see section <A HREF="mcsim.html#SEC46">Bibliographic References</A>) require the use of two
specifications, <STRONG>MonteCarlo()</STRONG> and <STRONG>Distrib()</STRONG>, which must
appear in the global section of the file, before the <CODE>Experiment</CODE>
sections.  Such Monte Carlo specifications are ignored if they appear in
an <CODE>Experiment</CODE> specification.
</P>
<P>
The <CODE>MonteCarlo</CODE> specification gives general information required
for the runs: the output file name, the number of runs to perform, and a
starting seed for the random number generator. Its syntax is:
</P>

<PRE>
MonteCarlo("&#60;OutputFilename&#62;", &#60;nRuns&#62;, &#60;RandomSeed&#62;);
</PRE>

<P>
The output filename is a string field and must be enclosed in quotes. If
a null-string "" is given, the default name <TT>`simmc.out'</TT> will be
used.  The seed of the pseudo-random number generator can be any
positive real number. Seeds between 1.0 and 2147483646.0 are used as is,
others are rescaled within those bounds (and a warning is issued). Here
is an example of use:
</P>

<PRE>
MonteCarlo("percsimmc.out", 5, 9386.630);
</PRE>

<P>
The parameters' sampling distributions are specified by a list of
<CODE>Distrib</CODE> specifications, as explained in the next section. The
format of the output file of Monte Carlo simulations is discussed later
(see section <A HREF="mcsim.html#SEC44">Analyzing results</A>).
</P>



<H3><A NAME="SEC33" HREF="mcsim.html#TOC33"><CODE>Distrib()</CODE> specification</A></H3>
<P>
<A NAME="IDX90"></A>
<A NAME="IDX91"></A>

</P>

<P>
This specification indicates which variable to sample, and its sampling
distribution. One <STRONG>Distrib()</STRONG> specification must be included for
each variable to sample. The specification file can include any number
of these commands at the global level, or within any <CODE>Level</CODE>
section in the case of Markov chain Monte Carlo sampling
(see section <A HREF="mcsim.html#SEC42">Specifying a statistical model</A>). The syntax is:
</P>

<PRE>
Distrib(&#60;identifier&#62;, &#60;iType&#62;, [&#60;shape parms&#62;]);
</PRE>

<P>
The <VAR>iType</VAR> field specifies the sampling distribution to use and can
be one of following:

</P>

<UL>
<LI>

<A NAME="IDX92"></A>
<A NAME="IDX93"></A>
<STRONG>Uniform</STRONG>,

<LI>

<A NAME="IDX94"></A>
<A NAME="IDX95"></A>
<STRONG>LogUniform</STRONG>,

<LI>

<A NAME="IDX96"></A>
<A NAME="IDX97"></A>
<STRONG>Normal</STRONG>,

<LI>

<A NAME="IDX98"></A>
<A NAME="IDX99"></A>
<STRONG>Normal_v</STRONG>,

<LI>

<A NAME="IDX100"></A>
<A NAME="IDX101"></A>
<STRONG>LogNormal</STRONG>,

<LI>

<A NAME="IDX102"></A>
<A NAME="IDX103"></A>
<STRONG>LogNormal_v</STRONG>,

<LI>

<A NAME="IDX104"></A>
<A NAME="IDX105"></A>
<STRONG>TruncNormal</STRONG>,

<LI>

<A NAME="IDX106"></A>
<A NAME="IDX107"></A>
<STRONG>TruncNormal_v</STRONG>,

<LI>

<A NAME="IDX108"></A>
<A NAME="IDX109"></A>
<STRONG>TruncLogNormal</STRONG>,

<LI>

<A NAME="IDX110"></A>
<A NAME="IDX111"></A>
<STRONG>TruncLogNormal_v</STRONG>,

<LI>

<A NAME="IDX112"></A>
<A NAME="IDX113"></A>
<STRONG>Beta</STRONG>,

<LI>

<A NAME="IDX114"></A>
<A NAME="IDX115"></A>
<STRONG>Gamma</STRONG>,

<LI>

<A NAME="IDX116"></A>
<A NAME="IDX117"></A>
<STRONG>InvGamma</STRONG>,

<LI>

<A NAME="IDX118"></A>
<A NAME="IDX119"></A>
<STRONG>Chi2</STRONG>,

<LI>

<A NAME="IDX120"></A>
<A NAME="IDX121"></A>
<STRONG>Exponential</STRONG>,

<LI>

<A NAME="IDX122"></A>
<A NAME="IDX123"></A>
<STRONG>Binomial</STRONG>,

<LI>

<A NAME="IDX124"></A>
<A NAME="IDX125"></A>
<STRONG>Poisson</STRONG>,

<LI>

<A NAME="IDX126"></A>
<A NAME="IDX127"></A>
<STRONG>Piecewise</STRONG>.
</UL>

<P>
The corresponding shape parameters (Bernardo and Smith, 1994; Gelman et
al., 1995) (see section <A HREF="mcsim.html#SEC46">Bibliographic References</A>) are as follow:
</P>

<UL>

<LI>

Uniform and log-uniform distributions: minimum and maximum of the
sampling range, real numbers in natural space.
<LI>

Normal distribution (two reals numbers): mean and standard deviation,
the latter being stricly positive. The variant <CODE>Normal_v</CODE> takes the
variance instead of the standard deviation as second parameter.
<LI>

Truncated normal distribution (four reals numbers): mean, standard
deviation (stricly positive), minimum and maximum. The variant
<CODE>TruncNormal_v</CODE> takes the variance instead of the standard
deviation as second parameter.
<LI>

LogNormal distribution (two reals numbers): geometric mean (exponential
of the mean in log-space) and geometric standard deviation (exponential,
stricly superior to 1, of the standard deviation in log-space). The
variant <CODE>LogNormal_v</CODE> takes the variance (in log-space!) instead of
the standard deviation as second parameter.
<LI>

Truncated Lognormal distribution (four reals numbers): geometric mean
and geometric standard deviation (stricly superior to 1), minimum and
maximum in natural space. For example:

<PRE>

Distrib(Var, TruncLogNormal, 1, 2.718, 0.01, 10)

</PRE>

samples <VAR>Var</VAR> such that
while <VAR>Var</VAR> is truncated to fall between 0.01 to 10. The variant
<CODE>TruncLogNormal_v</CODE> takes the variance (in log-space!) instead of
the standard deviation as second parameter.
<LI>

Beta distribution (at least two strictly positive real numbers): <VAR>A</VAR>
and <VAR>B</VAR>. By default the Beta distribution is defined over the
interval [0;1].  If a range is given for the beta distribution, the
[0;1] interval is mapped onto the specified range.
<LI>

Gamma distribution (two strictly positive real numbers): shape <VAR>a</VAR>
and inverse scale <VAR>b</VAR>.
<LI>

Inverse-gamma distribution (two strictly positive real numbers): shape
<VAR>a</VAR> and scale <VAR>b</VAR>.
<LI>

Chi-squared distribution (one strictly positive real number): <VAR>n</VAR>.
This distribution is the same as Gamma(<VAR>n</VAR>/2, 1/2).
<LI>

Exponential distribution (one strictly positive real number):
inverse-scale <VAR>b</VAR>.
<LI>

Binomial distribution (two strictly positive numbers, a real and an
integer): <VAR>p</VAR> (in the interval [0;1]), and <VAR>N</VAR>. If <VAR>N</VAR> is
not input as an integer it will be rounded down during the
simulations.
<LI>

Poisson distribution (a strictly positive real): rate <VAR>l</VAR>.
<LI>

<A NAME="IDX128"></A>
<A NAME="IDX129"></A>
Piecewise distribution (four reals): <VAR>minimum</VAR>, <VAR>a</VAR>, <VAR>b</VAR>,
<VAR>maximum</VAR>. The distribution has the form of a truncated triangle,
with a plateau between <VAR>a</VAR> and <VAR>b</VAR>. If 
the distribution is the triangular distribution.</UL>

<P>
The shape parameters of the above distribution specifications can
reference other parameters, provided than distributions for these have
already been defined. For example:

</P>

<PRE>
Distrib(A, Normal, 0, 1);
Distrib(B, Normal, A, 2);
</PRE>



<H3><A NAME="SEC34" HREF="mcsim.html#TOC34"><CODE>MCMC()</CODE> specification</A></H3>
<P>
<A NAME="IDX130"></A>
<A NAME="IDX131"></A>
<A NAME="IDX132"></A>

</P>

<P>
Markov chain Monte Carlo (MCMC) simulations, used in a Bayesian context,
allow the user to specify a statistical model (eventually hierarchical)
and sample parameters from their joint posterior distribution, given a
prior distribution for each parameter, a set of data to simulate, and
corresponding likelihoods. Sampling from the posterior is not immediate:
it requires the simulation chain, which start by sampling purely from
the prior, to reach equilibrium. Checking that equilibrium is obtained
is best achieved, in our opinion, by running multiple independent
chains. Hence these computations are very intensive. For a discussion of
Markov chain Monte Carlo and convergence issues you should consult the
appropriate statistical literature (for example, Bernardo and Smith,
1994; Gelman, 1992; Gelman et al., in press; Gelman et al., 1995; Gelman
and Rubin, 1992; Smith, 1991; Smith and Roberts, 1993)
(see section <A HREF="mcsim.html#SEC46">Bibliographic References</A>). Technically, MCSim uses
Metropolis-Hasting sampling and you do not need to worry about issues of
conjugacy or log-concavity of your prior or posterior distributions.
Like simple Monte Carlo simulations, MCMC simulations require the use of
two specifications, <STRONG>MCMC()</STRONG> and <CODE>Distrib()</CODE> and of one special
section definition: <STRONG>Level</STRONG>. The syntax for the <CODE>MCMC()</CODE>
specification is:
</P>

<PRE>
MCMC("&#60;OutputFilename&#62;", "&#60;RestartFilename&#62;", "", &#60;nRuns&#62;, 
     &#60;simTypeFlag&#62;, &#60;printFrequency&#62;, &#60;itersToPrint&#62;, &#60;RandomSeed&#62;);
</PRE>

<P>
The output filename is a string field and must be enclosed in quotes. If
a null-string "" is given, the default name <TT>`MCMC.default.out'</TT> will
be used.
</P>
<P>
If a restart file name (enclosed in quotes) is given, the first
simulations will be read from that file (which must be a text file).
This allows you to continue a chain where you left it, since an MCMC
output file can be used as a restart file with no change. Note that the
first line of the file (which typically contains column headers) is
skipped. Also, the number of lines in the file must be less than or
equal to <VAR>nRuns</VAR>. The first column of the file should be integers,
and the following columns (tab- or space-separated) should give the
various parameters, in the same order as specified in the list of
<CODE>Distrib()</CODE> specifications in the input file. The third field is
reserved for future use and should just be a pair of empty
quotes.
</P>

<P>
The integer <VAR>nRuns</VAR> gives the total number of runs to be performed,
including the runs eventually read in the restart file. The next field,
<VAR>simTypeFlag</VAR> should be either 0, 1, or 2. It should be set at zero
to start a chain of MCMC simulations. In that case, parameters are
updated by Metropolis steps, one at a time. If the value of
<VAR>simTypeFlag</VAR> is set to 1 or 2, a restart file must also be
specified. In the case of 1, the output file will contain codes for the
level sequence, experiment numbers, printing times, data values and the
corresponding model predictions, computed using the last parameter vector
of the restart file. This is useful to quickly check the model fit to
the data.  If <VAR>simTypeFlag</VAR> is equal to 2, the entire restart file
is used to compute the parameters' covariance matrix. All parameters are
then updated at once using a multivariate normal kernel as proposal
distribution of the Metropolis steps. This results in large improvement
in speed. However, we recommend that this option be used only when
convergence is approximately obtained (therefore, you should run MCMC
simulations with <VAR>simTypeFlag</VAR> set to 0 first, up to approximate
convergence, and then restart the chain with the flag at 2).
</P>
<P>
The integer <VAR>printFrequency</VAR> should be set to 1 if you want an
output at each iteration, to 2 if you want an output at every other
iteration etc.  <VAR>itersToPrint</VAR> is the number of final iterations for
which output is required (<I>e.g.</I>, 1000 will request output for the
last 1000 iterations; to print all iterations just set this parameter to
the value of <VAR>nRuns</VAR>). Note that if no restart file is used, the
first iteration is always printed, regardless of the value of
<VAR>itersToPrint</VAR>. Finally, the seed of the pseudo-random number
generator can be any positive real number. Seeds between 1.0 and
2147483646.0 are used as is, others are rescaled silently within those
bounds.
</P>
<P>
To use the MCMC specification, you must define a statistical model
precising each parameter's prior distribution, or conditional
distribution (in the case of a hierarchical model), and the data
likelihood (<I>i.e.</I>, the distribution of observation errors). These
distributions must be enclosed in a <CODE>Level</CODE> section and are
specified with <CODE>Distrib()</CODE> statements (see section <A HREF="mcsim.html#SEC42">Specifying a statistical model</A>). In the context of MCMC sampling, MCSim provides an
extension of the <CODE>Distrib()</CODE> specification. First, the first two
shape parameters of distributions may depend on other model parameters.
For example:
</P>

<PRE>
Distrib(A, Normal, 0, 1);
Distrib(B, Normal, A, C);
</PRE>

<P>
The data distribution is given by a similar statement, which uses the
specification <STRONG>Prediction()</STRONG> to differentiate data from their
predicted counterparts. The <CODE>Prediction()</CODE> specification can be
used for the first two shape parameters only (therefore, not for ranges,
except in the case of uniform or loguniform distributions). If
<CODE>Prediction()</CODE> is used for the first shape parameter, the variable
enclosed in parentheses must be the same as the variable whose
distribution is described. There should be one and only one distribution
specified for a given type of data in the whole input file (<I>i.e.</I>,
you cannot redefine a likelihood; this limitation will hopefully be
removed in a future release). Note that only states and outputs can use
<CODE>Prediction()</CODE> specifications (but you can always define an output
to be equal to a parameter or an input in your model file).  For
example:
</P>

<PRE>
Distrib(y, TruncNormal, Prediction(y), Prediction(z), -10, 10);
</PRE>

<P>
To recapitulate, the extended <CODE>Distrib()</CODE> syntax, for use with MCMC
simulations is therefore:
</P>

<PRE>
Distrib(&#60;identifier&#62;, &#60;iType&#62;, [&#60;shape parms&#62;]);
</PRE>

<P>
where the first two shape parameters can be Prediction(&#60;identifier&#62;), or
any model parameter or numerals, and the last two shape parameters
numerals only (this limitation will also be removed in a future
release).

</P>
<P>
If a statement like:

</P>

<PRE>
Distrib(Var, &#60;iType&#62;, Prediction(&#60;Var&#62;), Prediction(&#60;Other_Var&#62;), ...);
</PRE>

<P>
is used, the two variables <VAR>Var</VAR> and <VAR>Other_Var</VAR> must have
identical output times. It is then useful to group them in the same
<CODE>Print()</CODE> statement.
</P>
<P>
The other tool MCSim brings you to build a complete statistical model is
the <CODE>Level</CODE> keyword. The use of this keyword, is described below
(see section <A HREF="mcsim.html#SEC42">Specifying a statistical model</A>).
</P>
<P>
Finally, the format of the output file of MCMC simulations is discussed
in a later section (see section <A HREF="mcsim.html#SEC44">Analyzing results</A>).
</P>



<H3><A NAME="SEC35" HREF="mcsim.html#TOC35"><CODE>SetPoints()</CODE> specification</A></H3>
<P>
<A NAME="IDX133"></A>
<A NAME="IDX134"></A>

</P>

<P>
To impose a series of set points (i.e., already tabulated values for the
parameters), the global section can include a <STRONG>SetPoints()</STRONG>
specification.  It allows you to perform additional simulations with
previously Monte Carlo sampled parameter values, eventually filtered.
You can also generate parameters values in a systematic fashion,
over a grid for example, with another program, and use them as input to
MCSim. Importance sampling, latin hypercube sampling, grid sampling, can
be accommodated in this way.

</P>
<P>
This command specifies an output filename, the name of a text file
containing the chosen parameter values, the number of simulations to
perform and a list of model parameters to vary. It has the following
syntax:

</P>

<PRE>
SetPoints("&#60;OutputFilename&#62;", "&#60;SetPointsFilename&#62;", &#60;nRuns&#62;, 
          &#60;identifier&#62;, &#60;identifier&#62;, ...);
</PRE>

<P>
If a null string is given for the output filename, the set points output
will be written to the same default output file used for Monte Carlo
analyses, <TT>`simmc.out'</TT>.

</P>
<P>
The set points file name is required and must refer to an existing file
containing the parameter values to use. The first line of the set points
file is skipped and can contain column headers, for example. Each of the
other lines should contain an integer (<I>e.g.</I>, the line number)
followed by values of the various parameters in the order indicated in
the <CODE>SetPoints()</CODE> specification. If extra fields are at the end of
each line they are skipped. The first integer field is needed but not
used (this allows you to directly use Monte Carlo output files for
additional <CODE>SetPoints</CODE> simulations).
</P>
<P>
The variable <VAR>nRuns</VAR> should be less or equal to the number of lines
(minus one) in the set points file. If a zero is given, all lines of the
file are read. The format of the output file of set points simulations
is discussed below (see section <A HREF="mcsim.html#SEC44">Analyzing results</A>).
</P>
<P>
Following the <CODE>SetPoints()</CODE> specification, <CODE>Distrib()</CODE>
statements can be given for parameters not already in the list
(see section <A HREF="mcsim.html#SEC33"><CODE>Distrib()</CODE> specification</A>). These parameters will be sampled
accordingly before to performing each simulation. The shape parameters
of the distribution specifications can reference other parameters,
including those of the list.
</P>



<H2><A NAME="SEC36" HREF="mcsim.html#TOC36">Specifying basic conditions to simulate</A></H2>

<P>
Any simulation file must define at least one <CODE>Experiment</CODE> to
simulate.
</P>



<H3><A NAME="SEC37" HREF="mcsim.html#TOC37"><CODE>Experiment</CODE> definition</A></H3>
<P>
<A NAME="IDX135"></A>

</P>

<P>
After global simulation specifications, "experiments" must be included
in the input file.  They define simulation conditions and specify
outputs.  An "experiment" section starts with the keyword <STRONG>Experiment</STRONG>
and is enclosed in curly braces.
</P>
<P>
An "experiment" can make modifications to any model variable or
parameter that was defined in the global section of the model
description file.  The syntax is the same, except that variables or
parameters can only take constant values. So, for example, in an
experiment the body weight could be modified with:
</P>

<PRE>
BodyWt = 83.2;
</PRE>

<P>
This overrides any previously assigned values, even if randomly sampled,
for the specified parameter.

</P>
<P>
Inputs can be redefined with the input functions listed in the
<CODE>Mod</CODE> reference section above (see section <A HREF="mcsim.html#SEC13">Defining Models</A>). Input
functions can reference other variables (eventually random), as
in:
</P>

<PRE>
Q_gav = PerExp(GavMag, 60, 0, RateConst);
</PRE>

<P>
The maximum number of experiments definable is 200. This can be changed
by changing MAX_INSTANCES and MAX_EXPERIMENTS in the header file
<TT>`sim.h'</TT> and recompiling.  Within an experiment definition, or at
the global level (if you want them to apply to all experiments), several
additional specifications can also be used:
<UL>
<LI>

<STRONG>StartTime()</STRONG>,
<LI>

<STRONG>Print()</STRONG>,
<LI>

<STRONG>PrintStep()</STRONG>,
<LI>

<STRONG>Data()</STRONG>.
</UL>



<H3><A NAME="SEC38" HREF="mcsim.html#TOC38"><CODE>StartTime()</CODE> specification</A></H3>
<P>
<A NAME="IDX136"></A>
<A NAME="IDX137"></A>

</P>
<P>
The origin of time for a simulation, if it needs to be defined, is
specified with the <STRONG>StartTime()</STRONG> specification:
</P>

<PRE>
StartTime(&#60;initial-time&#62;);
</PRE>

<P>
If this specification is not given, a value of zero is used by default.
The final time is automatically computed to match the largest output
time specified in the <CODE>Print()</CODE> or <CODE>PrintStep()</CODE> statements
(see section <A HREF="mcsim.html#SEC39"><CODE>Print()</CODE> specification</A>; see section <A HREF="mcsim.html#SEC40"><CODE>PrintStep()</CODE> specification</A>).
</P>



<H3><A NAME="SEC39" HREF="mcsim.html#TOC39"><CODE>Print()</CODE> specification</A></H3>
<P>
<A NAME="IDX138"></A>
<A NAME="IDX139"></A>

</P>

<P>
The value of any model variable, input, output or parameter can be
requested for output with <STRONG>Print()</STRONG> specifications. Their arguments
are a list of names of variables (at least one and up to 10), and a list
of increasing times at which to output their value:
</P>

<PRE>
Print(&#60;identifier1&#62;, &#60;identifier2&#62;, ..., &#60;time1&#62;, &#60;time2&#62;, ...);
</PRE>

<P>
The same output times are used for all the variables specified. The size
of the time list is only limited by the available memory. The limit of
10 variables names can be increased by changing MAX_PRINT_VARS in the
header file <TT>`sim.h'</TT> and recompiling. The number of <CODE>Print()</CODE>
statements you can used in a given <CODE>Experiment</CODE> section is only
limited by the available memory.
</P>



<H3><A NAME="SEC40" HREF="mcsim.html#TOC40"><CODE>PrintStep()</CODE> specification</A></H3>
<P>
<A NAME="IDX140"></A>
<A NAME="IDX141"></A>

</P>

<P>
The value of any model variable, input or parameter can be also output
with <STRONG>PrintStep</STRONG> specifications. They allow dense printing, suitable
for smooth plots, for example. The arguments are the name of only one
variable, the first output time, the last one, and a time
increment:
</P>

<PRE>
PrintStep(&#60;identifier&#62;, &#60;start-time&#62;, &#60;end-time&#62;, &#60;time-step&#62;);
</PRE>

<P>
The final time has to be superior to the initial time and the time step
has to be less than the time span between end and start. If the time
step is not an exact divider of the time span the last printing step is
shorter and the last output time is still the end-time specified. The
number of outputs produced is only limited by the memory available at
run time. You can use several <CODE>PrintStep()</CODE> in a given
<CODE>Experiment</CODE> section.
</P>



<H3><A NAME="SEC41" HREF="mcsim.html#TOC41"><CODE>Data()</CODE> specification</A></H3>
<P>
<A NAME="IDX142"></A>
<A NAME="IDX143"></A>

</P>

<P>
Experimental observations of model variables, inputs, outputs, or
parameters, can be specified with the <STRONG>Data()</STRONG> command. Markov chain
Monte Carlo sampling requires that you specify <CODE>Data()</CODE> statements
(see section <A HREF="mcsim.html#SEC34"><CODE>MCMC()</CODE> specification</A>; see section <A HREF="mcsim.html#SEC42">Specifying a statistical model</A>).
The data are then used internally to evaluate the likelihood function
for the model.  The arguments are the name of the variable for which
observations exist, and a list of data values:
</P>

<PRE>
Data(&#60;identifier&#62;, &#60;value1&#62;, &#60;value2&#62;, ...);
</PRE>

<P>
This specification can only be used with a matching <CODE>Print()</CODE> or
<CODE>PrintStep()</CODE> for the same variable (see section <A HREF="mcsim.html#SEC39"><CODE>Print()</CODE> specification</A>;
see section <A HREF="mcsim.html#SEC40"><CODE>PrintStep()</CODE> specification</A>). You must make sure that there are as
many data values in the <CODE>Data()</CODE> specification as output time
requested in the corresponding <CODE>Print()</CODE> or <CODE>PrintStep()</CODE>. A
data value of "-1" is treated as "missing data" and ignored in
likelihood calculations. The convention "-1" can be changed by changing
INPUT_MISSING_VALUE in the header file <TT>`mc.h'</TT> and
recompiling.
</P>



<H2><A NAME="SEC42" HREF="mcsim.html#TOC42">Specifying a statistical model</A></H2>
<P>
<A NAME="IDX144"></A>
<A NAME="IDX145"></A>

</P>

<P>
Statistical models are defined in the simulation specification file,
rather than in the model definition file. It is necessary to define a
statistical model (with parameter dependencies, prior distributions and
likelihood) if you want to use MCMC sampling. MCMC sampling will then
give you in output a sample of parameters drawn from their joint
posterior distribution. Take for example the simple linear regression
model:
</P>
<P>
The first thing to do is to define a model to compute <VAR>y</VAR> as a
function of <VAR>x</VAR>. Here is such a model (quite similar to the one
distributed with MCSim source code (see section <A HREF="mcsim.html#SEC50"><TT>`linear.model'</TT></A>):
</P>

<PRE>
# ---------------------------------------------
# Model definition file for a linear model
# ---------------------------------------------
Outputs = {y};

# Model parameters
Alpha = 0;
Beta = 0;
Sigma2 = 1;
x_bar = 0;

CalcOutputs { y = Alpha + Beta * (t - x_bar); }
# ---------------------------------------------
</PRE>

<P>
The parameters' initialization values are arbitrary, and could be
anything reasonable. They will be changed or sampled through the input
file. Note that 
is not used in the model equations, but still
needs to be defined here in order to be part of the statistical
model. On the other hand, 
Finally <VAR>x</VAR> is replaced by the time, <CODE>t</CODE>, for convenience.
An alternative would be to define an input <SAMP>`x'</SAMP> and use it instead of 
<CODE>t</CODE>.
</P>
<P>
We now need to write an input file specifying the distribution of
<VAR>y</VAR> (<I>i.e.</I>, the likelihood), and the prior distributions of the
various parameters. Here is what such a file could look like:
</P>

<PRE>
# ---------------------------------------------------------------
# Simulation input file for a linear regression
# ---------------------------------------------------------------
SimType (MCMC);
MCMC ("linear.MCMC.out", "", "", 50000, 0, 5, 40000, 63453.1961);
Level {
  Distrib(Alpha,  Normal_v, 0, 10000);
  Distrib(Beta,   Normal_v, 0, 10000);
  Distrib(Sigma2, InvGamma, 0.01, 0.01);
  Distrib(y, Normal_v, Prediction(y), Sigma2);
  Experiment {
    x_bar = 3.0;
    PrintStep (y, 1, 5, 1);
    Data  (y, 1, 3, 3, 3, 5);
  }
} # end Level
End
# ---------------------------------------------------------------
</PRE>

<P>
The file begins the obvious <CODE>SimType()</CODE> (see section <A HREF="mcsim.html#SEC29"><CODE>SimType()</CODE> specification</A>) and <CODE>MCMC()</CODE> (see section <A HREF="mcsim.html#SEC34"><CODE>MCMC()</CODE> specification</A>)
keywords. The keyword <CODE>Level</CODE> comes next. <CODE>Level</CODE> is used to
specify the dependence between model parameters in a hierarchy. There
should be at least one <CODE>Level</CODE> in every MCMC input file, even for a
non-hierarchical model like the one above (actually, "non-hierarchical"
models can be thought of has having only one level of hierarchy). See
below for further discussion of the <CODE>Level</CODE> keyword. You can also
look at the MCMC input files provided as examples with MCSim source
code.  The <CODE>Distrib()</CODE> statements define the parameter priors.
<CODE>Normal_v</CODE> specifications are used since we use variances instead
of standard deviations. The inverse-Gamma distribution is used for the
variance component, since the precision is supposed to be
Gamma-distributed.  The likelihood is the distribution of the data,
given the model: it is also specified by a <CODE>Distrib()</CODE> statement,
valid for every <VAR>y</VAR> data point. Again, note that the
variable is not used. Instead the <CODE>Prediction(<VAR>y</VAR>)</CODE>
specification is used to signify the linear model output. These
distributions are in effect for every sub-level or every
<CODE>Experiment</CODE> included in the current level.
</P>
<P>
The "simulations" to perform, and the corresponding data values, are
specified by the <CODE>Experiment</CODE> section. Only one <CODE>Experiment</CODE>
is needed here, but several could be specified. In this section, the
value of
is provided. The different values of <VAR>x</VAR> (time in our model) can be
specified via a <CODE>PrintStep()</CODE> specification (see section <A HREF="mcsim.html#SEC40"><CODE>PrintStep()</CODE> specification</A>), since they are equally spaced. More generally, a
<CODE>Print()</CODE> specification could have been used (see section <A HREF="mcsim.html#SEC39"><CODE>Print()</CODE> specification</A>). The data values are given in a <CODE>Data()</CODE>
statement.
</P>



<H3><A NAME="SEC43" HREF="mcsim.html#TOC43"><CODE>Level</CODE> definition</A></H3>
<P>
<A NAME="IDX146"></A>

</P>

<P>
Markov chain Monte Carlo simulations require the definition of a
statistical model and the use of the <STRONG>Level</STRONG> keyword. At least one
level must be defined. A level section starts with the keyword
<CODE>Level</CODE> and is enclosed in curly braces. It can include any number
of sub-levels or <CODE>Experiments</CODE>. <CODE>Experiments</CODE> (where the data
are specified) form the lowest level of the hierarchy (see section <A HREF="mcsim.html#SEC37"><CODE>Experiment</CODE> definition</A>. There must be one and only one top level and at most 10
sub-levels in the hierarchy. This limit of 10 levels can be increased
(up to 255) by changing MAX_LEVELS in the header file <TT>`sim.h'</TT> and
recompiling.
</P>
<P>
A level can make modifications to the sampling distribution of any model
parameter. For example:

</P>

<PRE>
Level { # this is the top level

  Distrib(A, Uniform, 0, 1);

  Level { # this is sub-level 1
    Distrib(A, Normal, A, 1);
    Experiment { ... } # experiment 1
    Experiment { ... } # experiment 2
  }
}
</PRE>

<P>
These distribution assignments apply to all sub-levels of the level
where they take place. If several assignments are given, their position
within the level section is irrelevant (although a logical order is
recommended for clarity).

</P>
<P>
A level can also make modifications to any model parameter that was
defined in the global section of the model description file. The syntax
is the same, except that variables can only take constant values. So,
for example, in an experiment, the parameter <VAR>A</VAR> could be modified
with:
</P>

<PRE>
A = 2.0;
</PRE>

<P>
This overrides any previously assigned values, even if randomly sampled,
for the specified parameter. This assignment also applies to the
sub-levels of the level where they take place.

</P>
<P>
An important concept to grasp here is that of "instance". In the code
fragment given above, the parameter <VAR>A</VAR>, defined at sub-level 1, is
"cloned" as many times as there are sub-levels or experiments enclosed
in sub-level 1 (hence, it will be cloned twice in the example above,
once for each <CODE>Experiment</CODE> defined).  In that way, the parameters
distributions defined at one level in fact apply to the next lower
sub-level, or at the <CODE>Experiment</CODE> level. This convention saves a
lot writing and effort in the long run. For example, the uniform
distribution assigned to <VAR>A</VAR>, at the top level, applies to the
sub-level 1. There is only one "clone" of <VAR>A</VAR> at sub-level 1 since
only one sub-level is included in the top level. In contrast, two
normally-distributed "clones" of <VAR>A</VAR> will be defined and sampled.
The first one will apply to experiment 1, and will be conditioned by the
data of that experiment only, and the other will apply to experiment 2.
A total of three variables of "type" <VAR>A</VAR> will be sampled and will be
printed in the output file (coded so that the position in the hierarchy
is apparent): the "parent" <VAR>A(1)</VAR>, a priori uniformly distributed,
and two "dependents" <VAR>A(1.1)</VAR> and <VAR>A(1.2)</VAR>, <I>a priori</I>
normally distributed around <VAR>A(1)</VAR>.
</P>



<H2><A NAME="SEC44" HREF="mcsim.html#TOC44">Analyzing results</A></H2>
<P>
<A NAME="IDX147"></A>

</P>

<P>
The output from Monte Carlo or <CODE>SetPoints</CODE> simulations is a
tab-delimited text file with one row for each run (i.e., parameter set)
and one column for each parameter and output in the order specified.
Thus each line of the output file is in the following order:
</P>

<PRE>
&#60;# of run&#62; &#60;parameters&#62; &#60;outputs for Exp 1&#62; &#60;outputs for Exp2&#62; ...
</PRE>

<P>
The parameters are printed in the order they were sampled or set.

</P>
<P>
The first line gives the column headers. A variable called <VAR>name</VAR>
requested for output in an experiment <VAR>i</VAR> at a time <VAR>j</VAR> is
labeled <VAR>name_i.j</VAR>.
</P>
<P>
The output of Markov chain Monte Carlo simulations is also a text file
with one row for each run. It displays a column of iteration labels, and
one column for each parameter sampled. The last three columns contain
respectively, the sum of the logarithms of each parameter's density
given its parents' values (<SAMP>`LnPrior'</SAMP>), the logarithm of the data
likelihood (<SAMP>`LnData'</SAMP>), and the sum of the previous two values
(<SAMP>`LnPosterior'</SAMP>). The first line gives the column headers. On this
line, parameters names are tagged with a code identifying their position
in the hierarchy defined by the Level statements. For example, the
second instance of a parameter called <VAR>name</VAR> placed at the fist
level of the hierarchy is labeled <VAR>name(2)</VAR>; the first instance of
the same parameter placed at the second instance of the second level of
the hierarchy is labeled <VAR>name(2.1)</VAR>, etc.
</P>
<P>
The tab-delimited file can easily be imported into your favorite
spreadsheet, graphic or statistical package for further analysis.
</P>



<H2><A NAME="SEC45" HREF="mcsim.html#TOC45">Error Handling</A></H2>
<P>
<A NAME="IDX148"></A>

</P>

<P>
If integration fails for an <CODE>Experiment</CODE> in <CODE>DefaultSim</CODE>
simulations no output is generated for that experiment, and the user is
warned by an error message on the screen. In <CODE>MonteCarlo</CODE> or
<CODE>SetPoints</CODE> simulations, the corresponding simulation line is not
printed, but the iteration number is incremented. Finally, in
<CODE>MCMC</CODE> simulations, the parameter for which the data likelihood was
computed is simply not updated (which implicitly forbids the
uncomputable region of the parameter space). In all cases an error
message is given on the screen, or wherever the screen output has been
redirected.
</P>



<H1><A NAME="SEC46" HREF="mcsim.html#TOC46">Bibliographic References</A></H1>
<P>
<A NAME="IDX149"></A>

</P>

<P>
Barry, T. M. (1996). Recommendations on the testing and use of
pseudo-random number generators used in Monte Carlo analysis for risk
assessment. Risk Analysis <B>16</B>:93-105.

</P>
<P>
Bernardo, J. M. and Smith, A. F. M. (1994). Bayesian Theory. Wiley, New
York.

</P>
<P>
Bois, F. Y., Gelman, A., Jiang, J., Maszle, D., Zeise, L. and Alexeef,
G. (1996). Population toxicokinetics of tetrachloroethylene. Archives of
Toxicology <B>70</B>:347-355.

</P>
<P>
Bois, F. Y., Zeise, L. and Tozer, T. N. (1990). Precision and
sensitivity analysis of pharmacokinetic models for cancer risk
assessment: tetrachloroethylene in mice, rats and humans. Toxicology and
Applied Pharmacology <B>102</B>:300-315.

</P>
<P>
Gear, C. W. (1971a). Algorithm 407 - DIFSUB for solution of ordinary
differential equations [D2]. Communications of the ACM <B>14</B>:185-190.

</P>
<P>
Gear, C. W. (1971b). The automatic integration of ordinary differential
equations. Communications of the ACM <B>14</B>:176-179.

</P>
<P>
Gelman, A. (1992). Iterative and non-iterative simulation algorithms.
Computing Science and Statistics <B>24</B>:433-438.

</P>
<P>
Gelman, A., Bois, F. Y. and Jiang, J. (1996). Physiological
pharmacokinetic analysis using population modeling and informative prior
distributions. Journal of the American Statistical Association 
<B>91</B>:1400-1412.

</P>
<P>
Gelman, A., Carlin, J. B., Stern, H. S. and Rubin, D. B. (1995).
Bayesian Data Analysis. Chapman &#38; Hall, London.

</P>
<P>
Gelman, A. and Rubin, D. B. (1992). Inference from iterative simulation
using multiple sequences (with discussion). Statistical Science 
<B>7</B>:457-511.

</P>
<P>
Hammersley, J. M. and Handscomb, D. C. (1964). Monte Carlo Methods.
Chapman and Hall, London.

</P>
<P>
Manteufel, R. D. (1996). Variance-based importance analysis applied to a
complex probabilistic performance assessment. Risk Analysis 
<B>16</B>:587-598.

</P>
<P>
Park, S. K. and Miller, K. W. (1988). Random number generators: good
ones are hard to find. Communications of the ACM <B>31</B>:1192-1201.

</P>
<P>
Press, W. H., Flannery, B. P., Teukolsky, S. A. and Vetterling, W. T.
(1989). Numerical Recipes (2st ed.). Cambridge University Press,
Cambridge.

</P>
<P>
Smith, A. F. M. (1991). Bayesian computational methods. Philosophical
Transactions of the Royal Society of London, Series A <B>337</B>:369-386.

</P>
<P>
Smith, A. F. M. and Roberts, G. O. (1993). Bayesian computation via the
Gibbs sampler and related Markov chain Monte Carlo methods. Journal of
the Royal Statistical Society Series B <B>55</B>:3-23.

</P>
<P>
Vattulainen, I., Ala-Nissila, T. and Kankaala, K. (1994). Physical tests
for random numbers in simulations. Physical Review Letters 
<B>73</B>:2513-2516.

</P>



<H1><A NAME="SEC47" HREF="mcsim.html#TOC47">Common Pitfalls</A></H1>
<P>
<A NAME="IDX150"></A>
<A NAME="IDX151"></A>

</P>

<P>
The following mistakes are particularly easy to make, and sometimes
hard to notice, or understand at first. 

</P>

<UL>
<LI>

Putting a space before the end of line <KBD>;</KBD> in the
model definition file may causes strange error messages.
<LI>

Forgetting about type-related arithmetics in C: <SAMP>`1000/882'</SAMP> gives
<SAMP>`1'</SAMP> since it is interpreted as an integer division by the compiler.
To get a floating-point (usual) division use <SAMP>`1000./882.'</SAMP>.</UL>



<H1><A NAME="SEC48" HREF="mcsim.html#TOC48">Using <CODE>make</CODE></A></H1>
<P>
<A NAME="IDX152"></A>
<A NAME="IDX153"></A>

</P>

<P>
<CODE>Make</CODE> is a utility that facilitates doing repetitive tasks like
compilation. A <SAMP>`makefile'</SAMP> is a text file that contains a
description of what <CODE>make</CODE> should do and under what circumstances.
For example the compilation <TT>`Makefile'</TT> included with the MCSim
distribution only compile a C-file if it has changed since the last
compilation. This means that when you change your model and create a new
<TT>`model.c'</TT> file using mod, only the <TT>`model.c'</TT> file needs to be
compiled to recreate the simulation engine.
</P>
<P>
Before you run <CODE>make</CODE> for the first time on a machine you must
change some settings in the makefile to specify where your C compiler is
on your file system, and some special settings for that compiler. Refer
to the documentation (or manual pages in Unix) for your compiler to do
this. In the makefile file there are several variables defined which you
may need to change. They are described in the makefile itself.
</P>
<P>
You run the <CODE>make</CODE> program by entering <CODE>make</CODE> or <CODE>make -f
Makefile</CODE> at the prompt from the directory where the program is that you
want to compile.
</P>



<H1><A NAME="SEC49" HREF="mcsim.html#TOC49">Examples</A></H1>
<P>
<A NAME="IDX154"></A>

</P>

<P>
You will find here some examples of model description files and 
simulation iput files.

</P>



<H2><A NAME="SEC50" HREF="mcsim.html#TOC50"><TT>`linear.model'</TT></A></H2>


<PRE>
# Linear Model with a random component
# y = A + B * time + N(0,SD_true)
# Setting SD_true to zero gives the deterministic version
#---------------------------------------------------------

# Outputs
Outputs = {y};

# Model Parameters
A = 0;
B = 1;
SD_true = 0;
SD_esti = 0;

CalcOutputs { y = A + B * t + NormalRandom(0,SD_true); } 
</PRE>



<H2><A NAME="SEC51" HREF="mcsim.html#TOC51"><TT>`1cpt.model'</TT>: A sample model description file</A></H2>


<PRE>
# One Compartment Model
# First order input and output
#---------------------------------------------------------

# Inputs
Inputs = {Dose};

# Outputs
Outputs = {C_central, AUC, ln_C_central, ln_AUC,
           SD_C_computed, SD_A_computed};

# Model Parameters
ka = 1;
ke = 0.5;
F  = 1;
V  = 2;

# Statistical Parameters
SDb_ka = 0;
SDw_ka = 0;
SDb_ke = 0;
SDw_ke = 0;
SDb_V  = 0;
min_F  = 0;
max_F  = 0;
SD_C_central = 0;
SD_AUC       = 0;
CV_C_cen     = 0;
CV_AUC       = 0;
CV_C_cen_true = 0;
CV_AUC_true   = 0;

# Calculate Outputs
CalcOutputs {

  # algebraic equation for C_central
  C_central = (ka != ke ?
               (exp(-ke * t) - exp(-ka * t)) * 
               F * ka * Dose / (V * (ka - ke))):
               exp(-ka * t) * ka * t * F * Dose / V);

  # algebraic equation for AUC
  AUC = (ka != ke ?
         ((1 - exp(-ke * t)) / ke - (1 - exp(-ka * t)) / ka) * F * ka * Dose / 
         (V * (ka - ke))):
         F * Dose * (1 - (1 + ka * t) * exp(-ka * t)) / (V * ke));

  C_central = C_central + NormalRandom(0, C_central * CV_C_cen_true);
  AUC       = AUC + NormalRandom(0, AUC * CV_AUC_true);

  ln_C_central = (C_central &#62; 0 ? log (C_central) : -100);
  ln_AUC = (AUC &#62; 0 ? log (AUC) : -100);

  SD_C_computed = (C_central &#62; 0 ? C_central * CV_C_cen : 1e-10);
  SD_A_computed = (AUC &#62; 0 ? AUC * CV_AUC : 1e-10);

} # End of output calculations
</PRE>



<H2><A NAME="SEC52" HREF="mcsim.html#TOC52"><TT>`perc.model'</TT>: A sample model description file</A></H2>


<PRE>
#---------------------------------------------------------
# perc.model
# A four compartment model of Tetrachloroethylene (PERC)
# and total metabolites.
# Copyright (c) 1993.  Don Maszle, Frederic Bois.  All rights reserved.
#---------------------------------------------------------
# States are quantities of PERC and metabolite formed, they can be output

States = {Q_fat,        # Quantity of PERC in the fat
          Q_wp,         #   ...   in the well-perfused compartment
          Q_pp,         #   ...   in the poorly-perfused compartment
          Q_liv,        #   ...   in the liver
          Q_exh,        #   ...   exhaled
          Qmet};        # Quantity of metabolite formed

# Extra outputs are concentrations at various points

Outputs = {C_liv,               # mg/l in the liver
           C_alv,               # ... in the alveolar air
           C_exh,               # ... in the exhaled air
           C_ven,               # ... in the venous blood
           Pct_metabolized,     # % of the dose metabolized
           C_exh_ug};           # ug/l in the exhaled air

Inputs = {C_inh}                # Concentration inhaled

# Constants
# Conversions from/to ppm: 72 ppm = .488 mg/l

PPM_per_mg_per_l = 72.0 / 0.488;
mg_per_l_per_PPM = 1/PPM_per_mg_per_l;

#---------------------------------------------------------
# Nominal values for parameters
# Units:
# Volumes: liter
# Vmax:    mg / minute
# Weights: kg
# Km:      mg / minute
# Time:    minute
# Flows:   liter / minute
#---------------------------------------------------------

InhMag = 0.0;
Period = 0.0;
Exposure = 0.0;

C_inh = PerDose (InhMag, Period, 0.0, Exposure);

LeanBodyWt = 55;    # lean body weight

# Percent mass of tissues with ranges shown

Pct_M_fat  = .16;   # % total body mass
Pct_LM_liv = .03;   # liver, % of lean mass
Pct_LM_wp  = .17;   # well perfused tissue, % of lean mass
Pct_LM_pp  = .70;   # poorly perfused tissue, will be recomputed in scale

# Percent blood flows to tissues

Pct_Flow_fat = .09;
Pct_Flow_liv = .34;
Pct_Flow_wp  = .50; # will be recomputed in scale
Pct_Flow_pp  = .07;

# Tissue/blood partition coeficients

PC_fat = 144;
PC_liv = 4.6;
PC_wp  = 8.7;
PC_pp  = 1.4;
PC_art = 12.0;

Flow_pul   = 8.0;    # Pulmonary ventilation rate (minute volume)
Vent_Perf = 1.14;    # ventilation over perfusion ratio

sc_Vmax = .0026;     # scaling coeficient of body weight for Vmax

Km = 1.0;  

# The following parameters are calculated from the above values in 
# the Scale section before the start of each simulation.
# They are left uninitialized here.

BodyWt = 0;

V_fat = 0;           # Actual volume of tissues
V_liv = 0;
V_wp  = 0;
V_pp  = 0;

Flow_fat = 0;        # Actual blood flows through tissues
Flow_liv = 0;
Flow_wp  = 0;
Flow_pp  = 0;

Flow_tot = 0;        # Total blood flow
Flow_alv = 0;        # Alveolar ventilation rate

Vmax = 0;            # kg/minute

#---------------------------------------------------------
# Dynamics
# Define the dynamics of the simulation. This section is
# calculated with each integration step. It includes
# specification of differential equations.
#---------------------------------------------------------

Dynamics {

# Venous blood concentrations at the organ exit

Cout_fat = Q_fat / (V_fat * PC_fat);
Cout_wp  = Q_wp  / (V_wp  * PC_wp);
Cout_pp  = Q_pp  / (V_pp  * PC_pp);
Cout_liv = Q_liv / (V_liv * PC_liv);

# Sum of Flow * Concentration for all compartments

dQ_ven = Flow_fat * Cout_fat + Flow_wp * Cout_wp
         + Flow_pp * Cout_pp + Flow_liv * Cout_liv;

# Venous blood concentration

C_ven =  dQ_ven / Flow_tot;

# Arterial blood concentration
# Convert input given in ppm to mg/l to match other units

C_art = (Flow_alv * C_inh / PPM_per_mg_per_l +  dQ_ven) / 
        (Flow_tot + Flow_alv / PC_art);

# Alveolar air concentration

C_alv = C_art / PC_art;

# Exhaled air concentration
  
C_exh = 0.7 * C_alv + 0.3 * C_inh / PPM_per_mg_per_l;

# Differentials

dt (Q_exh) = Flow_alv * C_alv;
dt (Q_fat) = Flow_fat * (C_art - Cout_fat);
dt (Q_wp)  = Flow_wp  * (C_art - Cout_wp);
dt (Q_pp)  = Flow_pp  * (C_art - Cout_pp);

# Quantity metabolized in liver

dQmet_liv = Vmax * Q_liv / (Km + Q_liv);
dt (Q_liv) = Flow_liv * (C_art - Cout_liv) - dQmet_liv;

# Metabolite formation

dt (Qmet)  = dQmet_liv;

} # End of Dynamics

#---------------------------------------------------------
# Scale
# Scale certain model parameters and resolve dependencies
# between parameters. Generally the scaling involves a
# change of units, or conversion from percentage to actual
# units.
#---------------------------------------------------------

Scale {

# Volumes scaled to actual volumes

BodyWt = LeanBodyWt/(1 - Pct_M_fat);

V_fat = Pct_M_fat  * BodyWt/0.92;        # density of fat = 0.92 g/ml
V_liv = Pct_LM_liv * LeanBodyWt;
V_wp  = Pct_LM_wp  * LeanBodyWt;
V_pp  = 0.9 * LeanBodyWt - V_liv - V_wp; # 10% bones

# Calculate Flow_alv from total pulmonary flow

Flow_alv = Flow_pul * 0.7;

# Calculate total blood flow from the alveolar ventilation rate and 
# the V/P ratio.

Flow_tot = Flow_alv / Vent_Perf;
 
# Calculate actual blood flows from total flow and percent flows 

Flow_fat = Pct_Flow_fat * Flow_tot;
Flow_liv = Pct_Flow_liv * Flow_tot;
Flow_pp  = Pct_Flow_pp  * Flow_tot;
Flow_wp  = Flow_tot - Flow_fat - Flow_liv - Flow_pp;

# Vmax (mass/time) for Michaelis-Menten metabolism is scaled
# by multiplication of bdw^0.7 

Vmax = sc_Vmax * exp (0.7 * log (LeanBodyWt));

} # End of model scaling

#---------------------------------------------------------
# CalcOutputs 
# The following outputs are only calculated just before values
# are saved.  They are not calculated with each integration step.
#---------------------------------------------------------

CalcOutputs {

# Fraction of TCE metabolized per day

Pct_metabolized = (InhMag ?
                   Qmet / (1440 * Flow_alv * InhMag * mg_per_l_per_PPM) :
                   0);

C_exh_ug  = C_exh * 1000; # milli to micrograms

} # End of output calculation
</PRE>



<H2><A NAME="SEC53" HREF="mcsim.html#TOC53"><TT>`perc.lsodes.in'</TT></A></H2>


<PRE>
#---------------------------------------------------------
# perc.lsodes.in
#
# Copyright (c) 1993.  Don Maszle, Frederic Bois.  All rights reserved.
#
#---------------------------------------------------------

SimType (DefaultSim);

Integrate (Lsodes, 1e-4, 1e-6, 1);

#---------------------------------------------------------
# The following experiment is for a simulation of one of Dr. Monster's
# exposure experiments described in "Kinetics of Tetracholoroethylene 
# in Volunteers; Influence of Exposure Concentration and Work Load," 
# A.C. Monster, G. Boersma, and H. Steenweg, 
# Int. Arch. Occup. Environ. Health, v42, 1989, pp303-309
#
# The paper documents measurements of levels of TCE in blood and
# exhaled air for a group of 6 subjects exposed to 
# different concentrations of PERC in air.
#
# Inhalation is specified as a dose of magnitude InhMag for the
# given Exposure time.
#
# Inhalation is given in ppm
#---------------------------------------------------------

Experiment {

InhMag = 72;            # ppm
Period = 1e10;          # Only one dose
Exposure = 240;         # 4 hour exposure

# measurements before end of exposure and at [5' 30'] 2hr 18 42 67 91 139 163

Print (C_exh_ug, 239.9 245 270 360 1320 2760 4260 5700 8580 10020 );
Print (C_ven, 239.9 360 1320 2760 4260 5700 8580 10020 );

}

END.
</PRE>



<H1><A NAME="SEC54" HREF="mcsim.html#TOC54">Concept Index</A></H1>
<P>
     
<H2>'</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX19">'#' sign</A>
<LI><A HREF="mcsim.html#IDX21">';' sign</A>
</DIR>
<H2>a</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX147">Analyzing results</A>
<LI><A HREF="mcsim.html#IDX23">Assignment</A>
</DIR>
<H2>b</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX112">Beta distribution</A>
<LI><A HREF="mcsim.html#IDX149">Bibliographic references</A>
<LI><A HREF="mcsim.html#IDX122">Binomial distribution</A>
<LI><A HREF="mcsim.html#IDX20">Blank lines</A>
</DIR>
<H2>c</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX69">CalcOutputs, output specification</A>
<LI><A HREF="mcsim.html#IDX33">CDFNormal() function</A>
<LI><A HREF="mcsim.html#IDX118">Chi2 distribution</A>
<LI><A HREF="mcsim.html#IDX24">Colon conditional assignment</A>
<LI><A HREF="mcsim.html#IDX18">Comments</A>
<LI><A HREF="mcsim.html#IDX150">Common pitfalls</A>
<LI><A HREF="mcsim.html#IDX26">Comparison operators</A>
<LI><A HREF="mcsim.html#IDX25">Conditional assignment</A>
<LI><A HREF="mcsim.html#IDX36">Cumulative density function, Normal</A>
</DIR>
<H2>d</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX142">Data() specification</A>
<LI><A HREF="mcsim.html#IDX4">DefaultSim</A>
<LI><A HREF="mcsim.html#IDX12">Defining models</A>
<LI><A HREF="mcsim.html#IDX43">Density function, Normal</A>
<LI><A HREF="mcsim.html#IDX65">Derivative specification</A>
<LI><A HREF="mcsim.html#IDX90">Distrib() specification</A>
<LI><A HREF="mcsim.html#IDX113">Distribution, beta</A>
<LI><A HREF="mcsim.html#IDX123">Distribution, binomial</A>
<LI><A HREF="mcsim.html#IDX119">Distribution, chi2</A>
<LI><A HREF="mcsim.html#IDX121">Distribution, exponential</A>
<LI><A HREF="mcsim.html#IDX115">Distribution, gamma</A>
<LI><A HREF="mcsim.html#IDX117">Distribution, inverse-gamma</A>
<LI><A HREF="mcsim.html#IDX101">Distribution, lognormal</A>
<LI><A HREF="mcsim.html#IDX103">Distribution, lognormal_v</A>
<LI><A HREF="mcsim.html#IDX95">Distribution, loguniform</A>
<LI><A HREF="mcsim.html#IDX97">Distribution, normal</A>
<LI><A HREF="mcsim.html#IDX99">Distribution, normal_v</A>
<LI><A HREF="mcsim.html#IDX127">Distribution, piecewise</A>
<LI><A HREF="mcsim.html#IDX125">Distribution, Poisson</A>
<LI><A HREF="mcsim.html#IDX129">Distribution, triangular</A>
<LI><A HREF="mcsim.html#IDX109">Distribution, truncated lognormal</A>
<LI><A HREF="mcsim.html#IDX105">Distribution, truncated normal</A>
<LI><A HREF="mcsim.html#IDX111">Distribution, trunclognormal_v</A>
<LI><A HREF="mcsim.html#IDX107">Distribution, truncnormal_v</A>
<LI><A HREF="mcsim.html#IDX93">Distribution, uniform</A>
<LI><A HREF="mcsim.html#IDX64">Dt() operator</A>
<LI><A HREF="mcsim.html#IDX63">Dynamics specifications</A>
</DIR>
<H2>e</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX37">Erfc() function</A>
<LI><A HREF="mcsim.html#IDX38">Error function</A>
<LI><A HREF="mcsim.html#IDX148">Error handling</A>
<LI><A HREF="mcsim.html#IDX84">Euler integrator</A>
<LI><A HREF="mcsim.html#IDX14">Examples</A>, <A HREF="mcsim.html#IDX154">Examples</A>
<LI><A HREF="mcsim.html#IDX135">Experiment definition</A>
<LI><A HREF="mcsim.html#IDX120">Exponential distribution</A>
</DIR>
<H2>f</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX34">Function, CDFNormal()</A>
<LI><A HREF="mcsim.html#IDX39">Function, erfc()</A>
<LI><A HREF="mcsim.html#IDX41">Function, lnDFNormal()</A>
<LI><A HREF="mcsim.html#IDX45">Function, lnGamma()</A>
<LI><A HREF="mcsim.html#IDX60">Function, NDoses</A>
<LI><A HREF="mcsim.html#IDX51">Function, NormalRandom()</A>
<LI><A HREF="mcsim.html#IDX56">Function, PerDose()</A>
<LI><A HREF="mcsim.html#IDX58">Function, PerExp()</A>
<LI><A HREF="mcsim.html#IDX62">Function, Spikes()</A>
<LI><A HREF="mcsim.html#IDX48">Function, UniformRandom()</A>
<LI><A HREF="mcsim.html#IDX54">Functions, input</A>
<LI><A HREF="mcsim.html#IDX32">Functions, special</A>
</DIR>
<H2>g</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX114">Gamma distribution</A>
<LI><A HREF="mcsim.html#IDX46">Gamma function</A>
<LI><A HREF="mcsim.html#IDX77">Global specifications</A>
</DIR>
<H2>i</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX53">Input functions</A>
<LI><A HREF="mcsim.html#IDX29">Input variables</A>
<LI><A HREF="mcsim.html#IDX10">Installation</A>
<LI><A HREF="mcsim.html#IDX80">Integrate() specification</A>
<LI><A HREF="mcsim.html#IDX85">Integration routine, Euler</A>
<LI><A HREF="mcsim.html#IDX83">Integration routine, Lsodes</A>
<LI><A HREF="mcsim.html#IDX66">Integration variable</A>
<LI><A HREF="mcsim.html#IDX116">InvGamma distribution</A>
</DIR>
<H2>l</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX146">Level definition</A>
<LI><A HREF="mcsim.html#IDX2">License</A>
<LI><A HREF="mcsim.html#IDX40">LnDFNormal() function</A>
<LI><A HREF="mcsim.html#IDX44">LnGamma() function</A>
<LI><A HREF="mcsim.html#IDX100">Lognormal distribution</A>
<LI><A HREF="mcsim.html#IDX102">LogNormal_v distribution</A>
<LI><A HREF="mcsim.html#IDX94">LogUniform distribution</A>
<LI><A HREF="mcsim.html#IDX82">Lsodes integrator</A>
</DIR>
<H2>m</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX9">Major changes in versions 4.2.0</A>
<LI><A HREF="mcsim.html#IDX153">Make</A>
<LI><A HREF="mcsim.html#IDX7">Markov-chain Monte Carlo simulations</A>, <A HREF="mcsim.html#IDX132">Markov-chain Monte Carlo simulations</A>
<LI><A HREF="mcsim.html#IDX6">MCMC simulations</A>
<LI><A HREF="mcsim.html#IDX130">MCMC() specification</A>
<LI><A HREF="mcsim.html#IDX16">Mod syntax</A>
<LI><A HREF="mcsim.html#IDX15">Mod usage</A>
<LI><A HREF="mcsim.html#IDX13">Model definition files</A>
<LI><A HREF="mcsim.html#IDX72">Models</A>
<LI><A HREF="mcsim.html#IDX5">Monte Carlo</A>
<LI><A HREF="mcsim.html#IDX88">MonteCarlo() specification</A>
</DIR>
<H2>n</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX59">NDoses() function</A>
<LI><A HREF="mcsim.html#IDX35">Normal cumulative density function</A>
<LI><A HREF="mcsim.html#IDX42">Normal density function</A>
<LI><A HREF="mcsim.html#IDX96">Normal distribution</A>
<LI><A HREF="mcsim.html#IDX98">Normal_v distribution</A>
<LI><A HREF="mcsim.html#IDX50">NormalRandom() function</A>
</DIR>
<H2>o</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX70">Output specification</A>
<LI><A HREF="mcsim.html#IDX30">Output variables</A>
<LI><A HREF="mcsim.html#IDX86">OutputFile() specification</A>
<LI><A HREF="mcsim.html#IDX3">Overview</A>
</DIR>
<H2>p</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX27">Parameter declaration</A>
<LI><A HREF="mcsim.html#IDX68">Parameter scaling</A>
<LI><A HREF="mcsim.html#IDX55">PerDose() function</A>
<LI><A HREF="mcsim.html#IDX57">PerExp() function</A>
<LI><A HREF="mcsim.html#IDX126">Piecewise distribution</A>
<LI><A HREF="mcsim.html#IDX151">Pitfalls</A>
<LI><A HREF="mcsim.html#IDX124">Poisson distribution</A>
<LI><A HREF="mcsim.html#IDX138">Print() specification</A>
<LI><A HREF="mcsim.html#IDX140">PrintStep() specification</A>
</DIR>
<H2>r</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX52">Random number, normal</A>
<LI><A HREF="mcsim.html#IDX49">Random number, uniform</A>
</DIR>
<H2>s</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX67">Scale, scaling specification</A>
<LI><A HREF="mcsim.html#IDX22">Semi-colon</A>
<LI><A HREF="mcsim.html#IDX133">SetPoint() specification</A>
<LI><A HREF="mcsim.html#IDX8">SetPoints simulations</A>
<LI><A HREF="mcsim.html#IDX78">SimType() specification</A>
<LI><A HREF="mcsim.html#IDX74">Simulation definition files</A>
<LI><A HREF="mcsim.html#IDX75">Simulation file, syntax</A>
<LI><A HREF="mcsim.html#IDX1">Software license</A>
<LI><A HREF="mcsim.html#IDX31">Special functions</A>
<LI><A HREF="mcsim.html#IDX143">Specification, Data()</A>
<LI><A HREF="mcsim.html#IDX91">Specification, Distrib()</A>
<LI><A HREF="mcsim.html#IDX81">Specification, Integrate()</A>
<LI><A HREF="mcsim.html#IDX131">Specification, MCMC()</A>
<LI><A HREF="mcsim.html#IDX89">Specification, MonteCarlo()</A>
<LI><A HREF="mcsim.html#IDX87">Specification, OutputFile()</A>
<LI><A HREF="mcsim.html#IDX139">Specification, Print()</A>
<LI><A HREF="mcsim.html#IDX141">Specification, PrintStep()</A>
<LI><A HREF="mcsim.html#IDX134">Specification, SetPoint()</A>
<LI><A HREF="mcsim.html#IDX79">Specification, SimType()</A>
<LI><A HREF="mcsim.html#IDX137">Specification, StartTime()</A>
<LI><A HREF="mcsim.html#IDX145">Specification, statistical model</A>
<LI><A HREF="mcsim.html#IDX73">Specifying simulations</A>
<LI><A HREF="mcsim.html#IDX61">Spikes() function</A>
<LI><A HREF="mcsim.html#IDX136">StartTime() specification</A>
<LI><A HREF="mcsim.html#IDX28">State variables</A>
<LI><A HREF="mcsim.html#IDX144">Statistical model specification</A>
<LI><A HREF="mcsim.html#IDX71">Style</A>
<LI><A HREF="mcsim.html#IDX17">Syntax for mod</A>
<LI><A HREF="mcsim.html#IDX76">Syntax of simulation files</A>
</DIR>
<H2>t</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX128">Triangular distribution</A>
<LI><A HREF="mcsim.html#IDX108">TruncLogNormal distribution</A>
<LI><A HREF="mcsim.html#IDX110">TruncLogNormal_v distribution</A>
<LI><A HREF="mcsim.html#IDX104">TruncNormal distribution</A>
<LI><A HREF="mcsim.html#IDX106">TruncNormal_v distribution</A>
</DIR>
<H2>u</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX92">Uniform distribution</A>
<LI><A HREF="mcsim.html#IDX47">UniformRandom() function</A>
<LI><A HREF="mcsim.html#IDX152">Unix make utility</A>
</DIR>
<H2>w</H2>
<DIR>
<LI><A HREF="mcsim.html#IDX11">Working Through an Example</A>
</DIR>
     
<P><HR><P>
This document was generated on 15 November 1997 using the
<A HREF="http://wwwcn.cern.ch/dci/texi2html/">texi2html</A>
translator version 1.51.</P>
</BODY>
</HTML>
